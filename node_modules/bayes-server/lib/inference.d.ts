import { Node, Link, Network, IDistribution, IList, Variable, Table, CollectionAction, PropagationMethod, State, NodeDistributionKey, NodeDistributionKind, ICancellation } from './core';
/**
*  The type of algorithm to use when a network has decision nodes.
*/
export declare class DecisionAlgorithm {
    /**
*  The Single Policy Updating (SPU) algorithm is used when a network has Decision nodes.
*/
    static readonly SinglePolicyUpdating: DecisionAlgorithm;
    /**
*  Any decision nodes are treated like standard probability nodes.
*/
    static readonly None: DecisionAlgorithm;
    /**
*  Use the default algorithm.  The default algorithm is subject to change as new algorithms are developed.
*/
    static readonly Default: DecisionAlgorithm;
}
/**
*  Represents the evidence, or case data (e.g. row in a database) used in a {@link com.bayesserver.inference.IInference#query query}.
*
* Evidence is always associated with a particular network, however if necessary can be detached or attached to an instance of an inference engine. This has the follwing advantages: - Evidence can be set before an inference engine is created, or retained when an inference engine is destroyed. - Evidence can be switched between inference engines. - An inference engine can switch between different evidence instances.
*/
export declare class Evidence implements IEvidence {
    /**
* @inheritDoc
*/
    _1b3c77a7ef11437c93c3830de82e7500: string | null;
    private readonly _Cf_x_;
    private _Cg_x_;
    private _Ch_x_;
    private _Da_x_;
    private _Db_x_;
    private _Dc_x_;
    private _Dd_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.Evidence} class, with the target Bayesian network.
*
* @param {Network} network The target {@link com.bayesserver.Network}.
*/
    constructor(network: Network);
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.Evidence} class, and copies the evidence from another instance.
*
* @param {IEvidence} evidence The evidence to copy.
*/
    constructor(evidence: IEvidence);
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.Evidence} class, copying data from an existing {@link com.bayesserver.inference.Evidence} object.
*
* @param {Evidence} evidence The evidence.
*/
    constructor(evidence: Evidence);
    private _cons_autogen0(network);
    private _cons_autogen1(evidence);
    private _cons_autogen2(evidence);
    /**
*  Gets the count of variables with either hard, soft or temporal evidence set.

* @return {number} The count of variables with evidence.
*/
    readonly size: number;
    /**
* @inheritDoc
*/
    readonly network: Network;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    weight: number;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    logWeight: number;
    /**
* @inheritDoc
*/
    beginUpdate(): void;
    /**
*  Clears evidence on a variable at the specified time.
*
* @param {Variable} variable The variable whose evidence you want to clear.
*
* @param {?number} time The time at which to clear evidence.  Can be null.
*/
    clear(variable: Variable, time: number | null): void;
    /**
*  Clears evidence on a node's single variable.
*
* @param {Node} node A node with a single variable whose evidence you want to clear.
*
* @param {?number} time The time at which to clear evidence.  Can be null.
*/
    clear(node: Node, time: number | null): void;
    /**
*  Clears any evidence on a variable.
*
* @param {Variable} variable The variable to clear evidence on.
*/
    clear(variable: Variable): void;
    /**
*  Clears evidence on a node's variables.
*
* @param {Node} node The node whose variables you want to clear evidence on.

* @exception ReferenceError [node] is null.
*/
    clear(node: Node): void;
    /**
*  Clears any evidence on all variables.
*/
    clear(): void;
    private _Clear_autogen0(variable, time);
    private _Clear_autogen1(node, time);
    private _Clear_autogen2(variable);
    private _Clear_autogen3(node);
    private _Clear_autogen4();
    /**
* @inheritDoc
*/
    copy(evidence: IEvidence): void;
    /**
* @inheritDoc
*/
    copy(evidence: IEvidence, variable: Variable): void;
    /**
* @inheritDoc
*/
    copy(evidence: IEvidence, variable: Variable, time: number | null): void;
    private _Copy_autogen0(evidence);
    private _Copy_autogen1(evidence, variable);
    private _Copy_autogen2(evidence, variable, time);
    /**
* @inheritDoc
*/
    endUpdate(): void;
    /**
* @inheritDoc
*/
    get(variable: Variable): number | null;
    /**
* @inheritDoc
*/
    get(variable: Variable, time: number | null): number | null;
    /**
* @inheritDoc
*/
    get(node: Node, time: number | null): number | null;
    /**
* @inheritDoc
*/
    get(variable: Variable, destination: (number | null)[], destinationStart: number, startTime: number, count: number): void;
    /**
* @inheritDoc
*/
    get(node: Node, destination: (number | null)[], destinationStart: number, startTime: number, count: number): void;
    /**
* @inheritDoc
*/
    get(node: Node): number | null;
    private _Get_autogen0(variable);
    private _Get_autogen1(variable, time);
    private _Get_autogen2(node, time);
    private _Get_autogen3(variable, destination, destinationStart, startTime, count);
    private _Get_autogen4(node, destination, destinationStart, startTime, count);
    private _Get_autogen5(node);
    /**
* @inheritDoc
*/
    getEvidenceType(variable: Variable): EvidenceType;
    /**
* @inheritDoc
*/
    getEvidenceType(node: Node): EvidenceType;
    /**
* @inheritDoc
*/
    getEvidenceType(node: Node, time: number | null): EvidenceType;
    /**
* @inheritDoc
*/
    getEvidenceType(variable: Variable, time: number | null): EvidenceType;
    private _GetEvidenceType_autogen0(variable);
    private _GetEvidenceType_autogen1(node);
    private _GetEvidenceType_autogen2(node, time);
    private _GetEvidenceType_autogen3(variable, time);
    /**
* @inheritDoc
*/
    getMaxTime(variable: Variable): number | null;
    /**
* @inheritDoc
*/
    getMaxTime(): number | null;
    private _GetMaxTime_autogen0(variable);
    private _GetMaxTime_autogen1();
    /**
* @inheritDoc
*/
    getState(variable: Variable): number | null;
    /**
* @inheritDoc
*/
    getState(variable: Variable, time: number | null): number | null;
    /**
* @inheritDoc
*/
    getState(node: Node): number | null;
    /**
* @inheritDoc
*/
    getState(node: Node, time: number | null): number | null;
    private _GetState_autogen0(variable);
    private _GetState_autogen1(variable, time);
    private _GetState_autogen2(node);
    private _GetState_autogen3(node, time);
    /**
* @inheritDoc
*/
    getStates(variable: Variable, buffer: number[]): void;
    /**
* @inheritDoc
*/
    getStates(node: Node, buffer: number[]): void;
    /**
* @inheritDoc
*/
    getStates(table: Table): void;
    /**
* @inheritDoc
*/
    getStates(node: Node, buffer: number[], time: number | null): void;
    /**
* @inheritDoc
*/
    getStates(variable: Variable, buffer: number[], time: number | null): void;
    private _GetStates_autogen0(variable, buffer);
    private _GetStates_autogen1(node, buffer);
    private _GetStates_autogen2(table);
    private _GetStates_autogen3(node, buffer, time);
    private _GetStates_autogen4(variable, buffer, time);
    private _us_x_(p_autogen55, p_autogen56, p_autogen57);
    /**
* @inheritDoc
*/
    getVariables(buffer: Variable[]): void;
    /**
* @inheritDoc
*/
    set(variable: Variable, source: (number | null)[], sourceStart: number, startTime: number, count: number): void;
    /**
* @inheritDoc
*/
    set(node: Node, source: (number | null)[], sourceStart: number, startTime: number, count: number): void;
    /**
* @inheritDoc
*/
    set(variable: Variable, value: number | null): void;
    /**
* @inheritDoc
*/
    set(node: Node, value: number | null, time: number | null): void;
    /**
* @inheritDoc
*/
    set(variable: Variable, value: number | null, time: number | null): void;
    /**
* @inheritDoc
*/
    set(node: Node, value: number | null): void;
    private _Set_autogen0(variable, source, sourceStart, startTime, count);
    private _Set_autogen1(node, source, sourceStart, startTime, count);
    private _Set_autogen2(variable, value);
    private _Set_autogen3(node, value, time);
    private _Set_autogen4(variable, value, time);
    private _Set_autogen5(node, value);
    /**
* @inheritDoc
*/
    setState(variable: Variable, state: number | null): void;
    /**
* @inheritDoc
*/
    setState(variable: Variable, state: number | null, time: number | null): void;
    /**
* @inheritDoc
*/
    setState(state: State): void;
    /**
* @inheritDoc
*/
    setState(state: State, time: number | null): void;
    /**
* @inheritDoc
*/
    setState(node: Node, state: number | null): void;
    /**
* @inheritDoc
*/
    setState(node: Node, state: number | null, time: number | null): void;
    private _SetState_autogen0(variable, state);
    private _SetState_autogen1(variable, state, time);
    private _SetState_autogen2(state);
    private _SetState_autogen3(state, time);
    private _SetState_autogen4(node, state);
    private _SetState_autogen5(node, state, time);
    /**
* @inheritDoc
*/
    setStates(variable: Variable, values: number[]): void;
    /**
* @inheritDoc
*/
    setStates(node: Node, values: number[]): void;
    /**
* @inheritDoc
*/
    setStates(node: Node, values: number[], time: number | null): void;
    /**
* @inheritDoc
*/
    setStates(variable: Variable, values: number[], time: number | null): void;
    private _SetStates_autogen0(variable, values);
    private _SetStates_autogen1(node, values);
    private _SetStates_autogen2(node, values, time);
    private _SetStates_autogen3(variable, values, time);
    _uu_x_(p_autogen104: Node, p_autogen105: NodeDistributionKey, p_autogen106: NodeDistributionKind, p_autogen107: IDistribution, p_autogen108: IDistribution): void;
    _uv_x_(p_autogen109: number, p_autogen110: Link, p_autogen111: Link, p_autogen112: CollectionAction, p_autogen113: boolean): void;
    _vq_x_(p_autogen114: number, p_autogen115: Node, p_autogen116: Node, p_autogen117: CollectionAction, p_autogen118: boolean): void;
    _vr_x_(p_autogen119: Variable, p_autogen120: number, p_autogen121: State, p_autogen122: State, p_autogen123: CollectionAction, p_autogen124: boolean): void;
    _vs_x_(p_autogen125: number, p_autogen126: Variable, p_autogen127: Variable, p_autogen128: CollectionAction, p_autogen129: boolean): void;
    private _vu_x_(p_autogen132, p_autogen133, p_autogen134, p_autogen135);
    private _vv_x_(p_autogen136, p_autogen137, p_autogen138, p_autogen139);
    private _rqq_x_(p_autogen140, p_autogen141);
    private _rqr_x_(p_autogen142);
    private _rqs_x_(p_autogen143);
    private _rqt_x_(p_autogen144, p_autogen145, p_autogen146);
    private _rqu_x_(p_autogen147, p_autogen148, p_autogen149, p_autogen150);
    private _rqv_x_(p_autogen151);
    private _rrq_x_(p_autogen152, p_autogen153);
    private _rrr_x_(p_autogen154, p_autogen155);
    static _ut_x_(p_autogen102: Variable, p_autogen103: number | null): void;
    private static _vt_x_(p_autogen130, p_autogen131);
}
/**
*  The type of evidence for a variable.  When a variable is set to a specific value, this is called {@link com.bayesserver.inference.EvidenceType#Hard Hard} evidence.
*
*  For a discrete variable with a number of possible states, soft evidence implies that we have some information about the configuration of the states, but we are uncertain of the exact state.  For example if a node has 3 states and we are sure that the last state is not possible, we can have evidence of the form {1, 1, 0}.  We can also assign a distribution such as {0.3,0.4, 0.3}.
* <p>See {@link com.bayesserver.inference.IEvidence#setStates(Variable, double[])} for information on how to set this type of evidence.</p>

*/
export declare class EvidenceType {
    /**
*  No evidence has been set.  I.e. the variable's value is unknown/missing/null.
*/
    static readonly None: EvidenceType;
    /**
*  The value for the variable is known, such as the specific state of a discrete node.
*/
    static readonly Hard: EvidenceType;
    /**
*  A distribution is used to indicate evidence that is uncertain.
*
*  For a discrete variable with a number of possible states, soft evidence implies that we have some information about the configuration of the states, but we are uncertain of the exact state.  For example if a node has 3 states and we are sure that the last state is not possible, we can have evidence of the form {1, 1, 0}.  We can also assign a distribution such as {0.3,0.4, 0.3}.
* <p>See {@link com.bayesserver.inference.IEvidence#setStates(Variable, double[])} for information on how to set this type of evidence.</p>

*/
    static readonly Soft: EvidenceType;
    /**
*  The variable has evidence at one or more times.
*/
    static readonly Temporal: EvidenceType;
}
/**
*  Represents the evidence, or case data (e.g. row in a database) used in a {@link com.bayesserver.inference.IInference#query query}.
*
* Evidence is always associated with a particular network, however if necessary can be detached or attached to an instance of an inference engine. This has the follwing advantages: - Evidence can be set before an inference engine is created, or retained when an inference engine is destroyed. - Evidence can be switched between inference engines. - An inference engine can switch between different evidence instances.
*/
export interface IEvidence {
    _1b3c77a7ef11437c93c3830de82e7500: string | null;
    size: number;
    network: Network;
    weight: number;
    logWeight: number;
    beginUpdate(): void;
    clear(): void;
    clear(variable: Variable): void;
    clear(variable: Variable, time: number | null): void;
    clear(node: Node, time: number | null): void;
    clear(node: Node): void;
    copy(evidence: IEvidence): void;
    copy(evidence: IEvidence, variable: Variable): void;
    copy(evidence: IEvidence, variable: Variable, time: number | null): void;
    endUpdate(): void;
    getVariables(buffer: Variable[]): void;
    getMaxTime(variable: Variable): number | null;
    getMaxTime(): number | null;
    getEvidenceType(variable: Variable): EvidenceType;
    getEvidenceType(node: Node): EvidenceType;
    getEvidenceType(node: Node, time: number | null): EvidenceType;
    getEvidenceType(variable: Variable, time: number | null): EvidenceType;
    getState(variable: Variable): number | null;
    getState(variable: Variable, time: number | null): number | null;
    getState(node: Node): number | null;
    getState(node: Node, time: number | null): number | null;
    setState(variable: Variable, state: number | null): void;
    setState(variable: Variable, state: number | null, time: number | null): void;
    setState(state: State): void;
    setState(state: State, time: number | null): void;
    setState(node: Node, state: number | null): void;
    setState(node: Node, state: number | null, time: number | null): void;
    get(variable: Variable): number | null;
    get(variable: Variable, time: number | null): number | null;
    get(variable: Variable, destination: (number | null)[], destinationStart: number, startTime: number, count: number): void;
    get(node: Node, destination: (number | null)[], destinationStart: number, startTime: number, count: number): void;
    get(node: Node): number | null;
    get(node: Node, time: number | null): number | null;
    set(variable: Variable, value: number | null): void;
    set(variable: Variable, value: number | null, time: number | null): void;
    set(node: Node, value: number | null, time: number | null): void;
    set(variable: Variable, source: (number | null)[], sourceStart: number, startTime: number, count: number): void;
    set(node: Node, source: (number | null)[], sourceStart: number, startTime: number, count: number): void;
    set(node: Node, value: number | null): void;
    getStates(variable: Variable, buffer: number[]): void;
    getStates(node: Node, buffer: number[]): void;
    getStates(variable: Variable, buffer: number[], time: number | null): void;
    getStates(node: Node, buffer: number[], time: number | null): void;
    getStates(table: Table): void;
    setStates(variable: Variable, values: number[]): void;
    setStates(node: Node, values: number[]): void;
    setStates(variable: Variable, values: number[], time: number | null): void;
    setStates(node: Node, values: number[], time: number | null): void;
}
/**
*  The interface for a Bayesian network inference algorithm, which is used to perform queries such as calculating posterior probabilities and log-likelihood values for a case.
*
*  For an example of a class that implements this interface see {@link com.bayesserver.inference.relevancetree.RelevanceTreeInference}.
*/
export interface IInference {
    network: Network;
    evidence: IEvidence;
    baseEvidence: IEvidence;
    queryDistributions: IQueryDistributionCollection;
    query(queryOptions: IQueryOptions, queryOutput: IQueryOutput): void;
}
/**
*  Uses the factory design pattern to create inference related objects for inference algorithms.
*
*  An inference algorithm provides an implementation of this factory, which creates objects specific to that algorithm.
*/
export interface IInferenceFactory {
    createInferenceEngine(network: Network): IInference;
    createQueryOptions(): IQueryOptions;
    createQueryOutput(): IQueryOutput;
}
/**
*  Exception raised when either inconsistent evidence is detected, or underflow has occurred.
*/
export declare class InconsistentEvidenceError extends Error {
    /**
    *  Initializes a new instance of the {@link InconsistentEvidenceError} class.
    */
    constructor();
    /**
    *  Initializes a new instance of the {@link InconsistentEvidenceError} class with a specified error message.
    *
    * @param message The error message that explains the reason for the exception.
    */
    constructor(message: string);
}
/**
*  The collection of distributions to be calculated by a {@link com.bayesserver.inference.IInference#query}.  Only request those that you need.
*
*  If required, a distribution collection can be dynamically attached or detached from an {@link com.bayesserver.inference.IInference inference engine}. Also note that individual elements can be enabled or disabled on a per query basis.
* <p> Each distribution added, such as a {@link com.bayesserver.Table}, acts like a buffer.  I.e. the values are populated by the {@link com.bayesserver.inference.IInference#query} method. This means that the same distributions can be re-used across multiple calls to {@link com.bayesserver.inference.IInference#query}, without the need to recreate the distribution each time.</p>

* <p> It is important not to request distributions you do not need, because the computations will take longer.  For example, it is common to request all marginal probabilities, P(A), P(B), P(C), ... , P(Z) given the {@link com.bayesserver.inference.IEvidence evidence}, however if you only need to know P(A) and P(B) given the {@link com.bayesserver.inference.IEvidence evidence}, then limit the query to just these distributions.</p>

* <p> Typically the distributions requested are a number of marginal probabilities, such as P(A), P(B), P(C) etc... given the {@link com.bayesserver.inference.IEvidence evidence}, however it is also possible to request distributions over more than one variable, so we might query P(A), P(B,C) given the {@link com.bayesserver.inference.IEvidence evidence}.</p>

* <p> If you are performing a batch of queries, there is no need to remove distributions that happen to have evidence set for a particular query.</p>

* <p>For Dynamic Bayesian networks, times can be associated with distribution variables, to predict values in the future, present or past.</p>

*/
export interface IQueryDistributionCollection extends IList<QueryDistribution> {
    pushDistribution(distribution: IDistribution): QueryDistribution;
}
/**
*  Options that govern the calculations performed by {@link com.bayesserver.inference.IInference#query}.
*/
export interface IQueryOptions {
    logLikelihood: boolean;
    propagation: PropagationMethod;
    decisionAlgorithm: DecisionAlgorithm;
    conflict: boolean;
    queryEvidenceMode: QueryEvidenceMode;
    cancellation: ICancellation;
    terminalTime: number | null;
}
/**
*  Returns any information, in addition to the {@link com.bayesserver.inference.IQueryDistributionCollection distributions}, that is requested from a {@link com.bayesserver.inference.IInference#query query}.  For example the {@link com.bayesserver.inference.IQueryOutput#getLogLikelihood log-likelihood}.
*/
export interface IQueryOutput {
    logLikelihood: number | null;
    conflict: number | null;
    reset(): void;
}
/**
*  Determines whether and how queried values (e.g. probabilities) are adjusted to be comparisons.
*/
export declare class QueryComparison {
    /**
*  No comparison is made.  This is the default.
*/
    static readonly None: QueryComparison;
    /**
*  The difference between the current queried value and the value calculated using {@link com.bayesserver.inference.IInference#getBaseEvidence Base evidence}.  Returns a value between -1 and 1 for discrete values.
*
* This comparison is useful because it gives less weight when small probabilities are involved.
*/
    static readonly Difference: QueryComparison;
    /**
*  Each queried value is divided by its value when calculated using {@link com.bayesserver.inference.IInference#getBaseEvidence Base evidence}.
*
*
* <p>A value of NaN will be returned if the probability before and after is zero. This is by design.</p>

* <p>A value of Infinity will be returned if the probability before is zero and the probability after is positive. This is by design.</p>

*/
    static readonly Lift: QueryComparison;
}
/**
*  Type of distance to calculate for a query.
*/
export declare class QueryDistance {
    /**
*  No distance is calculated.
*/
    static readonly None: QueryDistance;
    /**
*  Kullback-Leibler divergence, D(P||Q) where Q is calculated using Base Evidence (or no evidence), and P is calculated from the standard evidence.
*/
    static readonly KLDivergence: QueryDistance;
}
/**
*  Defines a distribution to be queried in a call to {@link com.bayesserver.inference.IInference#query}.
*/
export declare class QueryDistribution {
    private _He_x_;
    private _Hf_x_;
    private _Hg_x_;
    private _Hh_x_;
    private _Baa_x_;
    private _Bab_x_;
    private _Bac_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.QueryDistribution} class.  The enabled property defaults to true.
*
* @param {IDistribution} distribution The distribution to query.
*/
    constructor(distribution: IDistribution);
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.QueryDistribution} class.
*
* @param {IDistribution} distribution The distribution to query.
*
* @param {boolean} isEnabled Sets the {@link com.bayesserver.inference.QueryDistribution#getIsEnabled} property.
*/
    constructor(distribution: IDistribution, isEnabled: boolean);
    private _cons_autogen0(distribution);
    private _cons_autogen1(distribution, isEnabled);
    /**
*  Gets a value indicating whether the distance should be calculated between the query calculated with base evidence (or no evidence), and the same query calculated with evidence.
*
*
* <p>The distance can be calculated against no evidence, or against base evidence which can be set on {@link com.bayesserver.inference.IInference#getBaseEvidence}.</p>

*/
    /**
*  Sets a value indicating whether the distance should be calculated between the query calculated with base evidence (or no evidence), and the same query calculated with evidence.
*
*
* <p>The distance can be calculated against no evidence, or against base evidence which can be set on {@link com.bayesserver.inference.IInference#getBaseEvidence}.</p>

*/
    queryDistance: QueryDistance;
    /**
*  Gets a value indicating whether queried values should be adjusted to show how they compare to the same query with no evidence, or base evidence.
*
*
* <p> Using comparisons is useful when you want to measure the difference or lift of a prediction value, for example when spotting unusual patterns during data exploration, or making recommendations.</p>

* <p>The comparison can be calculated based on no evidence, or against base evidence which can be set on {@link com.bayesserver.inference.IInference#getBaseEvidence}.</p>

*/
    /**
*  Sets a value indicating whether queried values should be adjusted to show how they compare to the same query with no evidence, or base evidence.
*
*
* <p> Using comparisons is useful when you want to measure the difference or lift of a prediction value, for example when spotting unusual patterns during data exploration, or making recommendations.</p>

* <p>The comparison can be calculated based on no evidence, or against base evidence which can be set on {@link com.bayesserver.inference.IInference#getBaseEvidence}.</p>

*/
    comparison: QueryComparison;
    /**
*  Determines whether or not to calculate the {@link com.bayesserver.inference.QueryDistribution#getLogLikelihood} specific to the evidence used to calculate this query.  For more information see {@link com.bayesserver.inference.QueryDistribution#getLogLikelihood}.
*/
    /**
*  Determines whether or not to calculate the {@link com.bayesserver.inference.QueryDistribution#getLogLikelihood} specific to the evidence used to calculate this query.  For more information see {@link com.bayesserver.inference.QueryDistribution#getLogLikelihood}.
*/
    queryLogLikelihood: boolean;
    /**
*  The log-likelihood specific to the evidence used to calculate this query.  Only calculated when {@link com.bayesserver.inference.QueryDistribution#getQueryLogLikelihood} is <code>true</code>.
*
*  The log-likelihood value will equal the overall {@link com.bayesserver.inference.IQueryOutput#getLogLikelihood} unless{@link com.bayesserver.inference.IQueryOptions#getQueryEvidenceMode} is set to {@link com.bayesserver.inference.QueryEvidenceMode#RetractQueryEvidence}, and there is evidence on at least one variable in the {@link com.bayesserver.IDistribution}.
* <p> When evidence is retracted for a particular query, this value contains the log likelihood of the remaining evidence.</p>

*/
    /**
*  The log-likelihood specific to the evidence used to calculate this query.  Only calculated when {@link com.bayesserver.inference.QueryDistribution#getQueryLogLikelihood} is <code>true</code>.
*
*  The log-likelihood value will equal the overall {@link com.bayesserver.inference.IQueryOutput#getLogLikelihood} unless{@link com.bayesserver.inference.IQueryOptions#getQueryEvidenceMode} is set to {@link com.bayesserver.inference.QueryEvidenceMode#RetractQueryEvidence}, and there is evidence on at least one variable in the {@link com.bayesserver.IDistribution}.
* <p> When evidence is retracted for a particular query, this value contains the log likelihood of the remaining evidence.</p>

*/
    logLikelihood: number | null;
    /**
*  The distance between this query calculated with base evidence or no evidence, and when calculated with evidence.  Only calculated when {@link com.bayesserver.inference.QueryDistribution#getQueryDistance} is not None.
*
*  This value can be null when the QueryDistance is set to None or the distance is undefined for the given queries.
*/
    /**
*  The distance between this query calculated with base evidence or no evidence, and when calculated with evidence.  Only calculated when {@link com.bayesserver.inference.QueryDistribution#getQueryDistance} is not None.
*
*  This value can be null when the QueryDistance is set to None or the distance is undefined for the given queries.
*/
    distance: number | null;
    /**
*  Gets a value indicating whether the distribution should be queried.

* @return {boolean} <code>true</code> if the distribution should be queried; otherwise, <code>false</code>.
*/
    /**
*  Sets a value indicating whether the distribution should be queried.
*
* @param {boolean} value <code>true</code> if the distribution should be queried; otherwise, <code>false</code>.
*/
    isEnabled: boolean;
    /**
*  Gets the distribution to query.

* @return {IDistribution} The distribution.
*/
    readonly distribution: IDistribution;
    /**
*  Returns a {@link String} that represents this instance.

* @return {string}  A {@link String} that represents this instance.
*/
    toString(): string;
}
/**
*  The collection of distributions to be calculated by a {@link com.bayesserver.inference.IInference#query}.  See {@link com.bayesserver.inference.IQueryDistributionCollection}.
*/
export declare class QueryDistributionCollection implements IList<QueryDistribution>, IQueryDistributionCollection {
    private _Bad_x_;
    private _items;
    private _Bae_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.QueryDistributionCollection} class, passing the target Bayesian network as a parameter.
*
* @param {Network} network The network that will be the target of the {@link com.bayesserver.inference.IInference#query}.
*/
    constructor(network: Network);
    /**
* @inheritDoc
*/
    _2ad2e5f4b2884a52bf8bfc07ce8953d3(): void;
    readonly size: number;
    /**
* @inheritDoc
*/
    insert(index: number, item: QueryDistribution): void;
    /**
* @inheritDoc
*/
    clear(): void;
    /**
*  Adds the specified distribution, automatically creating a {@link com.bayesserver.inference.QueryDistribution} instance.
*
* @param {IDistribution} distribution The distribution to query.

* @return {QueryDistribution} The automatically created {@link com.bayesserver.inference.QueryDistribution} instance.
*/
    pushDistribution(distribution: IDistribution): QueryDistribution;
    /**
* @inheritDoc
*/
    removeAt(index: number): QueryDistribution;
    /**
* @inheritDoc
*/
    set(index: number, item: QueryDistribution): void;
    get(index: number): QueryDistribution;
    /**
*  Gets the {@link com.bayesserver.Network} that is the target for a {@link com.bayesserver.inference.IInference#query}.
*/
    readonly network: Network;
    indexOf(item: QueryDistribution): number;
    includes(item: QueryDistribution): boolean;
    [Symbol.iterator](): Iterator<QueryDistribution>;
    push(...items: QueryDistribution[]): number;
    remove(item: QueryDistribution): boolean;
}
/**
*  Determines how predictions on variables with evidence are performed.
*/
export declare class QueryEvidenceMode {
    /**
*  When predictions are made on a variable with evidence, the prediction simply returns the evidence.
*/
    static readonly RetainQueryEvidence: QueryEvidenceMode;
    /**
*  When predictions are made on a variable with evidence, the variable's own evidence is ignored.
*
*  For example, consider a network with variables {A,B,C}, with evidence set on all variables. If you query {P(A),P(B),P(C)}, P(A) will only use the evidence on B and C, P(B) will only use the evidence on A and C,  and P(C) will only use the evidence on A and B.
* <p> This allows the prediction of variables, without having to perform multiple calls to {@link com.bayesserver.inference.IInference#query}, each time setting a different variable to null (missing).</p>

*/
    static readonly RetractQueryEvidence: QueryEvidenceMode;
}
/**
*  Helper methods for manipulating soft/virtual evidence.
{@link BayesServer.Inference.IEvidence.SetStates(Variable, double[])}    */
export declare class SoftEvidence {
    /**
*  Divides target soft evidence by an existing prior distribution or query.
*
*  This is often used so that when the soft evidence is applied during inference, it cancels out the prior or query.
*
* @param {Table} target
*
* @param {Table} prior

* @return {Table} The adjusted distribution.
*/
    static divideByPrior(target: Table, prior: Table): Table;
}
/**
*  Contains methods to determine properties of a Bayesian network or Dynamic Bayesian network when converted to a tree for inference.
*/
export declare class TreeQuery {
    /**
*  Calculates properties of a Bayesian network or Dynamic Bayesian network when converted to a tree for inference.
*
*
* <p> This is done without requiring the memory to actually perform inference, and so can be useful to test whether exact inference is feasible on a network, or determine approximate memory requirements.</p>

* <p>This can be done while taking into account any evidence currently set, and the particular queries that are being requested.</p>

*
* @param {Network} network The Bayesian network or Dynamic Bayesian network.
*
* @param {IQueryDistributionCollection} queryDistributions The distributions being queried.
*
* @param {IEvidence} evidence Any evidence.
*
* @param {TreeQueryOptions} queryOptions Options which affect how the query is performed.

* @return {TreeQueryOutput} Information about the tree, such as tree width.
*/
    static query(network: Network, queryDistributions: IQueryDistributionCollection, evidence: IEvidence, queryOptions: TreeQueryOptions): TreeQueryOutput;
}
/**
*  Options which affect the calculation performed by a {@link com.bayesserver.inference.TreeQuery}.
*/
export declare class TreeQueryOptions implements IQueryOptions {
    private _Bce_x_;
    private _Bcf_x_;
    private _Bcg_x_;
    private _Bch_x_;
    private _Bda_x_;
    private _Bdb_x_;
    private _Bdc_x_;
    private _Bdd_x_;
    private _Bde_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.TreeQueryOptions} class.
*/
    constructor();
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.TreeQueryOptions} class, copying options from another instance implementing {@link com.bayesserver.inference.IQueryOptions}.
*
* @param {IQueryOptions} queryOptions The query options to copy.

* @exception System.ArgumentNullException queryOptions
*/
    constructor(queryOptions: IQueryOptions);
    private _cons_autogen0();
    private _cons_autogen1(queryOptions);
    /**
*  Gets a value indicating whether or not to calculate the tree width.
*/
    /**
*  Sets a value indicating whether or not to calculate the tree width.
*/
    treeWidth: boolean;
    /**
*  Gets a value indicating whether to detect implied evidence during the calculation.
*
*  An example of implied evidence is:  Male => Not Pregnant.
*/
    /**
*  Sets a value indicating whether to detect implied evidence during the calculation.
*
*  An example of implied evidence is:  Male => Not Pregnant.
*/
    isImpliedEvidenceEnabled: boolean;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    terminalTime: number | null;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    propagation: PropagationMethod;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    decisionAlgorithm: DecisionAlgorithm;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    cancellation: ICancellation;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    logLikelihood: boolean;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    conflict: boolean;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    queryEvidenceMode: QueryEvidenceMode;
}
/**
*  Contains information output by a {@link com.bayesserver.inference.TreeQuery}.
*/
export declare class TreeQueryOutput {
    private _Bdf_x_;
    constructor(p_autogen0: number | null);
    /**
*  Gets the tree width, if requested.
*
*  The tree width gives an indication of how much space is required to calculate the queries using exact inference, given the evidence.
*/
    readonly treeWidth: number | null;
}
/**
*  An exact inference algorithm for Bayesian networks and Dynamic Bayesian networks, loosely based on the Variable Elimination algorithm.

* @see com.bayesserver.inference.relevancetree.RelevanceTreeInference

* @see com.bayesserver.inference.IInference
*/
export declare class VariableEliminationInference implements IInference {
    private readonly _Che_x_;
    private _Chf_x_;
    private _Chg_x_;
    private _Chh_x_;
    private _Daa_x_;
    private _Dab_x_;
    private _Dac_x_;
    private _Dad_x_;
    private _Dae_x_;
    private _Daf_x_;
    private _Dag_x_;
    private _Dah_x_;
    private _Dba_x_;
    private _Dbb_x_;
    private _Dbc_x_;
    private _Dbd_x_;
    private _Dbe_x_;
    private _Dbf_x_;
    private _Dbg_x_;
    private _Dbh_x_;
    private _Dca_x_;
    private _Dcb_x_;
    private _Dcc_x_;
    private _Dcd_x_;
    private _Dce_x_;
    private _Dcf_x_;
    private _Dcg_x_;
    private _Dch_x_;
    private _Dda_x_;
    private static readonly _Ddb_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.variableelimination.VariableEliminationInference} class, with the target Bayesian network.
*
* @param {Network} network The target {@link com.bayesserver.Network}.

* @exception ReferenceError Raised if [network] is null.
*/
    constructor(network: Network);
    /**
*  Gets the evidence (case data, e.g. row in a database) used in a {@link com.bayesserver.inference.IInference#query query}.
*
*  The {@link com.bayesserver.inference.IInference#getQueryDistributions distributions} are only recalculated when {@link com.bayesserver.inference.IInference#query} is called, not each time evidence is changed.
*/
    /**
*  Sets the evidence (case data, e.g. row in a database) used in a {@link com.bayesserver.inference.IInference#query query}.
*
*  The {@link com.bayesserver.inference.IInference#getQueryDistributions distributions} are only recalculated when {@link com.bayesserver.inference.IInference#query} is called, not each time evidence is changed.
*/
    evidence: IEvidence;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    baseEvidence: IEvidence;
    /**
*  The collection of distributions required from a {@link com.bayesserver.inference.IInference#query}.  Only request those that you need.
*
*
* <p> Each distribution added, such as a {@link com.bayesserver.Table}, acts like a buffer.  I.e. the values are populated by the {@link com.bayesserver.inference.IInference#query} method. This means that the same distributions can be resused across multiple calls to {@link com.bayesserver.inference.IInference#query}, without the need to recreate the distribution each time.</p>

* <p> It is important not to request distributions you do not need, because the computations will take longer.  For example, it is common to request all marginal probabilities, P(A), P(B), P(C), ... , P(Z) given the {@link com.bayesserver.inference.IEvidence evidence}, however if you only need to know P(A) and P(B) given the {@link com.bayesserver.inference.IEvidence evidence}, then limit the query to just these distributions.</p>

* <p> Typically the distributions requested are a number of marginal propabilities, such as P(A), P(B), P(C) etc... given the {@link com.bayesserver.inference.IEvidence evidence}, however it is also possible to request distributions over more than one variable, so we might query P(A), P(B,C) given the {@link com.bayesserver.inference.IEvidence evidence}.</p>

* <p> If you are performing a batch of queries, there is no need to remove those distributions that you require, however happen to have evidence set for a particular query.</p>

*/
    /**
*  The collection of distributions required from a {@link com.bayesserver.inference.IInference#query}.  Only request those that you need.
*
*
* <p> Each distribution added, such as a {@link com.bayesserver.Table}, acts like a buffer.  I.e. the values are populated by the {@link com.bayesserver.inference.IInference#query} method. This means that the same distributions can be resused across multiple calls to {@link com.bayesserver.inference.IInference#query}, without the need to recreate the distribution each time.</p>

* <p> It is important not to request distributions you do not need, because the computations will take longer.  For example, it is common to request all marginal probabilities, P(A), P(B), P(C), ... , P(Z) given the {@link com.bayesserver.inference.IEvidence evidence}, however if you only need to know P(A) and P(B) given the {@link com.bayesserver.inference.IEvidence evidence}, then limit the query to just these distributions.</p>

* <p> Typically the distributions requested are a number of marginal propabilities, such as P(A), P(B), P(C) etc... given the {@link com.bayesserver.inference.IEvidence evidence}, however it is also possible to request distributions over more than one variable, so we might query P(A), P(B,C) given the {@link com.bayesserver.inference.IEvidence evidence}.</p>

* <p> If you are performing a batch of queries, there is no need to remove those distributions that you require, however happen to have evidence set for a particular query.</p>

*/
    queryDistributions: IQueryDistributionCollection;
    /**
* @inheritDoc
*/
    readonly network: Network;
    private _uus_x_();
    private _uut_x_();
    _uuu_x_(): void;
    _uuv_x_(): void;
    private _uvq_x_(p_autogen1, p_autogen2, p_autogen3, p_autogen4);
    /**
* @inheritDoc
*/
    query(queryOptions: IQueryOptions, queryOutput: IQueryOutput): void;
    private _uvs_x_(p_autogen9, p_autogen10, p_autogen11, p_autogen12);
    private static _uvr_x_(p_autogen7, p_autogen8);
    private static _uvt_x_(p_autogen15, p_autogen16, p_autogen17, p_autogen18, p_autogen19, p_autogen20, p_autogen21, p_autogen22, p_autogen23, p_autogen24, p_autogen25, p_autogen26, p_autogen27);
}
/**
*  Uses the factory design pattern to create inference related objects for the Variable elimination algorithm.  See {@link com.bayesserver.inference.IInferenceFactory} for more details.
*/
export declare class VariableEliminationInferenceFactory implements IInferenceFactory {
    /**
*  Uses the factory design pattern to create inference related objects for the Variable elimination algorithm.  See {@link com.bayesserver.inference.IInferenceFactory} for more details.
*
* @param {Network} network The target Bayesian network.

* @return {IInference} The inference algorithm/engine.
*/
    createInferenceEngine(network: Network): IInference;
    /**
*  Creates a {@link com.bayesserver.inference.variableelimination.VariableEliminationQueryOptions} instance that governs the calculations performed by the {@link com.bayesserver.inference.variableelimination.VariableEliminationInference#query} method.

* @return {IQueryOptions} The options for use with {@link com.bayesserver.inference.variableelimination.VariableEliminationInference#query}.
*/
    createQueryOptions(): IQueryOptions;
    /**
*  Creates a {@link com.bayesserver.inference.variableelimination.VariableEliminationQueryOutput} instance that collects information about each {@link com.bayesserver.inference.variableelimination.VariableEliminationInference#query query}, in addition to the {@link com.bayesserver.inference.IQueryDistributionCollection distributions}.
*
*
* <p>The output object can be created once, and reused over many calls to {@link com.bayesserver.inference.IInference#query}.</p>


* @return {IQueryOutput} The output instance.
*/
    createQueryOutput(): IQueryOutput;
}
/**
*  Options that govern the calculations performed by {@link com.bayesserver.inference.IInference#query}.
*/
export declare class VariableEliminationQueryOptions implements IQueryOptions {
    private _Ddd_x_;
    private _Dde_x_;
    private _Ddf_x_;
    private _Ddg_x_;
    private _Ddh_x_;
    private _Dea_x_;
    private _Deb_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.variableelimination.VariableEliminationQueryOptions} class.
*/
    constructor();
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    terminalTime: number | null;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    propagation: PropagationMethod;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    decisionAlgorithm: DecisionAlgorithm;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    cancellation: ICancellation;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    logLikelihood: boolean;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    conflict: boolean;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    queryEvidenceMode: QueryEvidenceMode;
}
/**
*  Returns any information, in addition to the {@link com.bayesserver.inference.IQueryDistributionCollection distributions}, that is requested from a {@link com.bayesserver.inference.IInference#query query}.  For example the {@link com.bayesserver.inference.IQueryOutput#getLogLikelihood log-likelihood}.
*/
export declare class VariableEliminationQueryOutput implements IQueryOutput {
    private _Dec_x_;
    private _Ded_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.variableelimination.VariableEliminationQueryOutput} class.
*/
    constructor();
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    logLikelihood: number | null;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    conflict: number | null;
    /**
* @inheritDoc
*/
    reset(): void;
}
/**
*  An exact probabilistic inference algorithm for Bayesian networks and Dynamic Bayesian networks, that can compute multiple distributions more efficiently than the {@link com.bayesserver.inference.variableelimination.VariableEliminationInference} algorithm.

* @see com.bayesserver.inference.IInference
*/
export declare class RelevanceTreeInference implements IInference {
    private readonly _Dhh_x_;
    private _Eaa_x_;
    private _Eab_x_;
    private _Eac_x_;
    private _Ead_x_;
    private _Eae_x_;
    private _Eaf_x_;
    private _Eag_x_;
    private _Eah_x_;
    private _Eba_x_;
    private _Ebb_x_;
    private _Ebc_x_;
    private _Ebd_x_;
    private _Ebe_x_;
    private _Ebf_x_;
    private _Ebg_x_;
    private _Ebh_x_;
    private _Eca_x_;
    private _Ecb_x_;
    private _Ecc_x_;
    private _Ecd_x_;
    private _Ece_x_;
    private _Ecf_x_;
    private _Ecg_x_;
    private _Ech_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.relevancetree.RelevanceTreeInference} class, with the target Bayesian network.
*
* @param {Network} network The target {@link com.bayesserver.Network}.

* @exception ReferenceError Raised if [network] is null.
*/
    constructor(network: Network);
    /**
* @inheritDoc
*/
    readonly network: Network;
    private _vst_x_();
    private _vsu_x_();
    _vsv_x_(): void;
    _vtq_x_(): void;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    evidence: IEvidence;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    baseEvidence: IEvidence;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    queryDistributions: IQueryDistributionCollection;
    private _vtr_x_(p_autogen1);
    /**
* @inheritDoc
*/
    query(queryOptions: IQueryOptions, queryOutput: IQueryOutput): void;
    private _vts_x_(p_autogen6, p_autogen7, p_autogen8, p_autogen9, p_autogen10, p_autogen11, p_autogen12);
    private static _vtt_x_(p_autogen18, p_autogen19, p_autogen20, p_autogen21, p_autogen22, p_autogen23, p_autogen24);
    private static _vtu_x_(p_autogen28, p_autogen29);
    private static _vtv_x_(p_autogen30, p_autogen31);
}
/**
*  Uses the factory design pattern to create inference related objects for the Relevance Tree algorithm.  See {@link com.bayesserver.inference.IInferenceFactory} for more details.
*/
export declare class RelevanceTreeInferenceFactory implements IInferenceFactory {
    /**
*  Uses the factory design pattern to create inference related objects for the Relevance Tree algorithm.  See {@link com.bayesserver.inference.IInferenceFactory} for more details.
*
* @param {Network} network The target Bayesian network.

* @return {IInference} The inference algorithm/engine.
*/
    createInferenceEngine(network: Network): IInference;
    /**
*  Creates a {@link com.bayesserver.inference.relevancetree.RelevanceTreeQueryOptions} instance that governs the calculations performed by the {@link com.bayesserver.inference.relevancetree.RelevanceTreeInference#query} method.

* @return {IQueryOptions} The options for use with {@link com.bayesserver.inference.relevancetree.RelevanceTreeInference#query}.
*/
    createQueryOptions(): IQueryOptions;
    /**
*  Creates a {@link com.bayesserver.inference.relevancetree.RelevanceTreeQueryOutput} instance that collects information about each {@link com.bayesserver.inference.relevancetree.RelevanceTreeInference#query query}, in addition to the {@link com.bayesserver.inference.IQueryDistributionCollection distributions}.
*
*
* <p>The output object can be created once, and reused over many calls to {@link com.bayesserver.inference.IInference#query}.</p>


* @return {IQueryOutput} The output instance.
*/
    createQueryOutput(): IQueryOutput;
}
/**
*  Options that govern the calculations performed by {@link com.bayesserver.inference.IInference#query}.
*/
export declare class RelevanceTreeQueryOptions implements IQueryOptions {
    private _Edb_x_;
    private _Edc_x_;
    private _Edd_x_;
    private _Ede_x_;
    private _Edf_x_;
    private _Edg_x_;
    private _Edh_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.relevancetree.RelevanceTreeQueryOptions} class.
*/
    constructor();
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    logLikelihood: boolean;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    propagation: PropagationMethod;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    decisionAlgorithm: DecisionAlgorithm;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    conflict: boolean;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    cancellation: ICancellation;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    terminalTime: number | null;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    queryEvidenceMode: QueryEvidenceMode;
}
/**
*  Returns any information, in addition to the {@link com.bayesserver.inference.IQueryDistributionCollection distributions}, that is requested from a {@link com.bayesserver.inference.IInference#query query}.  For example the {@link com.bayesserver.inference.IQueryOutput#getLogLikelihood log-likelihood}.
*/
export declare class RelevanceTreeQueryOutput implements IQueryOutput {
    private _Eea_x_;
    private _Eeb_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.inference.relevancetree.RelevanceTreeQueryOutput} class.
*/
    constructor();
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    logLikelihood: number | null;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    conflict: number | null;
    /**
* @inheritDoc
*/
    reset(): void;
}
