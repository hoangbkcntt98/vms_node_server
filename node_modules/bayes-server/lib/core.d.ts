export declare class VariableId {
    static readonly Zero: VariableId;
    static readonly One: VariableId;
    private _Dhb_x_;
    private static readonly _Dhc_x_;
    private constructor();
    increment(): VariableId;
    private _rqsv_x_(p_autogen1, p_autogen2);
    compareTo(that: VariableId): number;
    private _rqtq_x_(p_autogen4, p_autogen5);
}
/**
*  Contains methods to reverse the direction of a {@link com.bayesserver.Link}, known as arc reversal.
*/
export declare class ArcReversal {
    /**
*  Reverse the direction of a {@link com.bayesserver.Link} (known as arc reversal).
*
* @param {Link} link The link whose direction should be changed.
*/
    static reverse(link: Link): void;
    private static _q_x_(p_autogen1);
    private static _r_x_(p_autogen2);
    private static _s_x_(p_autogen3, p_autogen4);
}
/**
*  Stores the position and size of an element.
*/
export declare class Bounds {
    private _A_x_;
    private _B_x_;
    private _C_x_;
    private _D_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.Bounds} class.
*
* @param {number} x The x-axis value of the left side of the element.
*
* @param {number} y The y-axis value of the top side of the element.
*
* @param {number} width The width of the element.
*
* @param {number} height The height of the element.
*/
    constructor(x: number, y: number, width: number, height: number);
    /**
*  Gets the x-axis value of the left side of the element.
*/
    readonly x: number;
    /**
*  Gets the y-axis value of the top side of the element.
*/
    readonly y: number;
    /**
*  Gets the width of the element.
*/
    readonly width: number;
    /**
*  Gets the height of the element.
*/
    readonly height: number;
}
/**
*  Class for canceling long running operations.

* @see com.bayesserver.ICancellation
*/
export declare class Cancellation implements ICancellation {
    private cancel_AUTO_GENERATED;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    cancel: boolean;
}
/**
*  Represents a Conditional Linear Gaussian probability distribution.
*
*  The distribution contains a {@link com.bayesserver.Table} distribution which represents any discrete combinations, and for each combination there exists a multivariate Gaussian distribution and weight/regression coefficients. Note that head variables are those that appear to the left of the bar in the expression P(A|B) and tail variables are those to the right.
*/
export declare class CLGaussian implements IDistribution {
    /**
* @inheritDoc
*/
    _39d9d5f7317c4bb79bd3c1e43b2b4a43: string | null;
    private _E_x_;
    private static readonly _F_x_;
    private static readonly _G_x_;
    private static readonly _H_x_;
    private static readonly _Ba_x_;
    private static _Bb_x_;
    private static readonly _Bc_x_;
    private _Bd_x_;
    private _Be_x_;
    private _Bf_x_;
    private _Bg_x_;
    private _Bh_x_;
    private _Ca_x_;
    private _Cb_x_;
    private _Cc_x_;
    private _Cd_x_;
    private _Ce_x_;
    private _Cf_x_;
    private _Cg_x_;
    private static _Ch_x_;
    private static _Da_x_;
    private static readonly _Db_x_;
    private static readonly _Dc_x_;
    constructor(variableContexts: VariableContext[]);
    constructor(variableContexts: IList<VariableContext>);
    constructor(variableContexts: IList<VariableContext>, headTail: HeadTail);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class with [count] variables specified in [variableContexts].
*
*  Each variable, if it belongs to a temporal node can have an associated time.  A variable is also marked as either head or tail. Head variables are those on the left, and tail variables are those on the right in the expression P(A|B).
*
* @param {VariableContext[]} variableContexts The variable contexts containing the distribution variables.
*
* @param {number} count The number of items to include from [variableContexts].

* @exception ReferenceError Raised if [variableContexts] is null.
*/
    constructor(variableContexts: VariableContext[], count: number);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class with [count] variables specified in [variableContexts].
*
*  Each variable, if it belongs to a temporal node can have an associated time.  A variable is also marked as either head or tail. Head variables are those on the left, and tail variables are those on the right in the expression P(A|B).
*
* @param {VariableContext[]} variableContexts The variable contexts containing the distribution variables.
*
* @param {number} count The number of items to include from [variableContexts].
*
* @param {HeadTail} headTail Overrides the Head or Tail value found in each {@link com.bayesserver.VariableContext}.

* @exception ReferenceError Raised if [variableContexts] is null.
*/
    constructor(variableContexts: VariableContext[], count: number, headTail: HeadTail);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class with the variables of a single node at the specified time.  Variables are assumed to be head variables.
*
* @param {Node} node The node whose variables will belong to the new distribution.
*
* @param {?number} time The time for any temporal nodes/variables.

* @exception ReferenceError Raised if [node] is null.
*/
    constructor(node: Node, time: number | null);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class with the specified variables at a particular time.  Variables are assumed to be head variables.
*
* @param {IList<Variable>} variables The variables for the new distribution.
*
* @param {?number} time The time for any temporal nodes/variables.

* @exception ReferenceError Raised if [variables] is null.

* @exception Error Raised if an element of [variables] is null or a variable does not belong to a network.
*/
    constructor(variables: IList<Variable>, time: number | null);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class with the specified variables.
*
* @param {IList<Variable>} variables The variables for the new distribution.
*
* @param {HeadTail} headTail Specifies whether the variables should be marked as Head or Tail.

* @exception ReferenceError Raised if [variables] is null.

* @exception Error Raised if an element of [variables] is null or a variable does not belong to a network.
*/
    constructor(variables: IList<Variable>, headTail: HeadTail);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class with the specified variables.
*
* @param {IList<Variable>} variables The variables for the new distribution.
*
* @param {?number} time The time for any temporal nodes/variables.
*
* @param {HeadTail} headTail Specifies whether the variables should be marked as Head or Tail.

* @exception ReferenceError Raised if [variables] is null.

* @exception Error Raised if an element of [variables] is null or a variable does not belong to a network.
*/
    constructor(variables: IList<Variable>, time: number | null, headTail: HeadTail);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class with the specified variables.  Variables are assumed to be head variables.
*
* @param {IList<Variable>} variables The variables for the new distribution.
*/
    constructor(variables: IList<Variable>);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class with the specified variables.  Variables are assumed to be head variables.
*
* @param {Variable[]} variables The variables for the new distribution.
*/
    constructor(variables: Variable[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class with the variables of a single node.  Variables are assumed to be head variables.
*
* @param {Node} node The node whose variables will belong to the new distribution.
*/
    constructor(node: Node);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class with a single variable.  The variable is assumed to be a head variable.
*
* @param {Variable} variable The variable that will belong to the new distribution.
*/
    constructor(variable: Variable);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class from a single {@link com.bayesserver.VariableContext}.
*
* @param {VariableContext} variableContext The variable context.

* @exception ReferenceError Raised when [variableContext] is null.
*/
    constructor(variableContext: VariableContext);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class with a single variable at the specified time.  The variable is assumed to be a head variable.
*
* @param {Variable} variable The variable that will belong to the new distribution.
*
* @param {?number} time The time associated with the variable.

* @exception ReferenceError Raised if [variable] is null.
*/
    constructor(variable: Variable, time: number | null);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class, copying the source distribution.
*
* @param {CLGaussian} source The distribution to copy.
*/
    constructor(source: CLGaussian);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CLGaussian} class, copying the source distribution but shifting any times by the specified number of units.
*
* @param {CLGaussian} source The distribution to copy.
*
* @param {?number} timeShift The number of units to adjust any times associated with variables.
*/
    constructor(source: CLGaussian, timeShift: number | null);
    private _cons_autogen0(variableContexts);
    private _cons_autogen1(variableContexts);
    private _cons_autogen2(variableContexts, headTail);
    private _cons_autogen3(variableContexts, count);
    private _cons_autogen4(variableContexts, count, headTail);
    private _cons_autogen5(node, time);
    private _cons_autogen6(variables, time);
    private _cons_autogen7(variables, headTail);
    private _cons_autogen8(variables, time, headTail);
    private _cons_autogen9(variables);
    private _cons_autogen10(variables);
    private _cons_autogen11(node);
    private _cons_autogen12(variable);
    private _cons_autogen13(variableContext);
    private _cons_autogen14(variable, time);
    private _cons_autogen15(source);
    private _cons_autogen16(source, timeShift);
    /**
* @inheritDoc
*/
    toString(): string;
    /**
*  Resets all mean, covariance and weight entries to zero.
*/
    reset(): void;
    private _t_x_(p_autogen9, p_autogen10, p_autogen11, p_autogen12);
    /**
*  Shifts any times associated with the distribution variables by the specified number of time units.
*
* @param {number} units The number of time units to shift.  Can be negative if required.
*/
    timeShift(units: number): void;
    private _u_x_(p_autogen25);
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    locked: boolean;
    /**
* @inheritDoc
*/
    isReadOnly(): boolean;
    /**
*  Creates a copy of the distribution.  The new distribution will not have an owner.

* @return {IDistribution} A copy of this instance.
*/
    copy(): IDistribution;
    /**
*  Creates a copy of the distribution, and shifts any times associated with variables by the specified amount.  The new distribution will not have an owner.
*
* @param {?number} timeShift The amount to shift any times present in the distribution.  Can be negative.

* @return {IDistribution}  A copy of this instance, with shifted times.
*/
    copy(timeShift: number | null): IDistribution;
    private _Copy_autogen0();
    private _Copy_autogen1(timeShift);
    private _rr_x_();
    /**
*  Gets the mean of the Gaussian distribution at the specified [index] in the {@link com.bayesserver.Table} of discrete combinations.
*
* @param {number} index The index into the discrete table of combinations.  If no discrete variables are present in the distribution, index will always be 0.
*
* @param {number} sortedContinuousHead The position of the required continuous head variable.

* @return {number} The mean value.
*/
    getMean(index: number, sortedContinuousHead: number): number;
    /**
*  Gets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the [discrete] combination.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The mean value.
*/
    getMean(continuousHead: Variable, discrete: State[]): number;
    /**
*  Gets the mean value of a Gaussian distribution with no discrete variables for the specified [continuousHead] variable.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).

* @return {number} The mean value.
*/
    getMean(continuousHead: Variable): number;
    /**
*  Gets the mean value of a Gaussian distribution with no discrete variables for the specified [continuousHead] variable and time.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.

* @return {number} The mean value.
*/
    getMean(continuousHead: Variable, time: number | null): number;
    /**
*  Gets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the [discrete] combination.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The mean value.
*/
    getMean(continuousHead: Variable, time: number | null, discrete: State[]): number;
    /**
*  Gets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the [discrete] combination.
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The mean value.
*/
    getMean(continuousHead: VariableContext, discrete: State[]): number;
    /**
*  Gets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the [discrete] combination.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The mean value.
*/
    getMean(continuousHead: Variable, discrete: StateContext[]): number;
    /**
*  Gets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the [discrete] combination.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The mean value.
*/
    getMean(continuousHead: Variable, time: number | null, discrete: StateContext[]): number;
    /**
*  Gets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the [discrete] combination.
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The mean value.
*/
    getMean(continuousHead: VariableContext, discrete: StateContext[]): number;
    /**
*  Gets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the discrete combination.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.

* @return {number} The mean value.
*/
    getMean(continuousHead: Variable, iterator: TableIterator): number;
    /**
*  Gets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the discrete combination.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.

* @return {number} The mean value.
*/
    getMean(continuousHead: Variable, time: number | null, iterator: TableIterator): number;
    /**
*  Gets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the discrete combination.
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.

* @return {number} The mean value.
*/
    getMean(continuousHead: VariableContext, iterator: TableIterator): number;
    private _GetMean_autogen0(index, sortedContinuousHead);
    private _GetMean_autogen1(continuousHead, discrete);
    private _GetMean_autogen2(continuousHead);
    private _GetMean_autogen3(continuousHead, time);
    private _GetMean_autogen4(continuousHead, time, discrete);
    private _GetMean_autogen5(continuousHead, discrete);
    private _GetMean_autogen6(continuousHead, discrete);
    private _GetMean_autogen7(continuousHead, time, discrete);
    private _GetMean_autogen8(continuousHead, discrete);
    private _GetMean_autogen9(continuousHead, iterator);
    private _GetMean_autogen10(continuousHead, time, iterator);
    private _GetMean_autogen11(continuousHead, iterator);
    _rs_x_(p_autogen41: number, p_autogen42: number): number;
    /**
*  Gets the variance of the Gaussian distribution at the specified [index] in the {@link com.bayesserver.Table} of discrete combinations.
*
* @param {number} index The index into the discrete table of combinations.  If no discrete variables are present in the distribution, index will always be 0.
*
* @param {number} sortedContinuousHead The position of the required continuous head variable.

* @return {number} The variance.
*/
    getVariance(index: number, sortedContinuousHead: number): number;
    /**
*  Gets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The variance value.
*/
    getVariance(continuousHead: Variable, discrete: State[]): number;
    /**
*  Gets the variance of a Gaussian distribution with no discrete variables for the specified [continuousHead] variable.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).

* @return {number} The variance value.
*/
    getVariance(continuousHead: Variable): number;
    /**
*  Gets the variance of a Gaussian distribution with no discrete variables for the specified [continuousHead] variable.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.

* @return {number} The variance value.
*/
    getVariance(continuousHead: Variable, time: number | null): number;
    /**
*  Gets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The variance value.
*/
    getVariance(continuousHead: Variable, time: number | null, discrete: State[]): number;
    /**
*  Gets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The variance value.
*/
    getVariance(continuousHead: VariableContext, discrete: State[]): number;
    /**
*  Gets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The variance value.
*/
    getVariance(continuousHead: Variable, discrete: StateContext[]): number;
    /**
*  Gets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The variance value.
*/
    getVariance(continuousHead: Variable, time: number | null, discrete: StateContext[]): number;
    /**
*  Gets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The variance value.
*/
    getVariance(continuousHead: VariableContext, discrete: StateContext[]): number;
    /**
*  Gets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.

* @return {number} The variance value.
*/
    getVariance(continuousHead: Variable, iterator: TableIterator): number;
    /**
*  Gets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.

* @return {number} The variance value.
*/
    getVariance(continuousHead: Variable, time: number | null, iterator: TableIterator): number;
    /**
*  Gets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.

* @return {number} The variance value.
*/
    getVariance(continuousHead: VariableContext, iterator: TableIterator): number;
    private _GetVariance_autogen0(index, sortedContinuousHead);
    private _GetVariance_autogen1(continuousHead, discrete);
    private _GetVariance_autogen2(continuousHead);
    private _GetVariance_autogen3(continuousHead, time);
    private _GetVariance_autogen4(continuousHead, time, discrete);
    private _GetVariance_autogen5(continuousHead, discrete);
    private _GetVariance_autogen6(continuousHead, discrete);
    private _GetVariance_autogen7(continuousHead, time, discrete);
    private _GetVariance_autogen8(continuousHead, discrete);
    private _GetVariance_autogen9(continuousHead, iterator);
    private _GetVariance_autogen10(continuousHead, time, iterator);
    private _GetVariance_autogen11(continuousHead, iterator);
    _rt_x_(p_autogen69: number, p_autogen70: number): number;
    /**
*  Gets the covariance of the Gaussian distribution at the specified [index] in the {@link com.bayesserver.Table} of discrete combinations.
*
* @param {number} index The index into the discrete table of combinations.  If no discrete variables are present in the distribution, index will always be 0.
*
* @param {number} sortedContinuousHeadA The position of the first continuous head variable.
*
* @param {number} sortedContinuousHeadB The position of the second continuous head variable.

* @return {number} The covariance entry.
*/
    getCovariance(index: number, sortedContinuousHeadA: number, sortedContinuousHeadB: number): number;
    /**
*  Gets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The covariance value.
*/
    getCovariance(continuousHeadA: Variable, continuousHeadB: Variable, discrete: State[]): number;
    /**
*  Gets the covariance of a Gaussian distribution with no discrete variables between [continuousHeadA] and [continuousHeadB].
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).

* @return {number} The covariance value.
*/
    getCovariance(continuousHeadA: Variable, continuousHeadB: Variable): number;
    /**
*  Gets the covariance of a Gaussian distribution with no discrete variables between [continuousHeadA] and [continuousHeadB].
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeA The time of the first continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeB The time of the second continuous head variable, or null if not a temporal variable.

* @return {number} The covariance value.
*/
    getCovariance(continuousHeadA: Variable, timeA: number | null, continuousHeadB: Variable, timeB: number | null): number;
    /**
*  Gets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The covariance value.
*/
    getCovariance(continuousHeadA: Variable, continuousHeadB: Variable, discrete: StateContext[]): number;
    /**
*  Gets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeA The time of the first continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeB The time of the second continuous head variable, or null if not a temporal variable.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The covariance value.
*/
    getCovariance(continuousHeadA: Variable, timeA: number | null, continuousHeadB: Variable, timeB: number | null, discrete: State[]): number;
    /**
*  Gets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeA The time of the first continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeB The time of the second continuous head variable, or null if not a temporal variable.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The covariance value.
*/
    getCovariance(continuousHeadA: Variable, timeA: number | null, continuousHeadB: Variable, timeB: number | null, discrete: StateContext[]): number;
    /**
*  Gets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHeadA A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {VariableContext} continuousHeadB A second continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The covariance value.
*/
    getCovariance(continuousHeadA: VariableContext, continuousHeadB: VariableContext, discrete: State[]): number;
    /**
*  Gets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHeadA A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {VariableContext} continuousHeadB A second continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The covariance value.
*/
    getCovariance(continuousHeadA: VariableContext, continuousHeadB: VariableContext, discrete: StateContext[]): number;
    /**
*  Gets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.

* @return {number} The covariance value.
*/
    getCovariance(continuousHeadA: Variable, continuousHeadB: Variable, iterator: TableIterator): number;
    /**
*  Gets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeA The time of the first continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeB The time of the second continuous head variable, or null if not a temporal variable.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.

* @return {number} The covariance value.
*/
    getCovariance(continuousHeadA: Variable, timeA: number | null, continuousHeadB: Variable, timeB: number | null, iterator: TableIterator): number;
    /**
*  Gets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHeadA A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {VariableContext} continuousHeadB A second continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.

* @return {number} The covariance value.
*/
    getCovariance(continuousHeadA: VariableContext, continuousHeadB: VariableContext, iterator: TableIterator): number;
    private _GetCovariance_autogen0(index, sortedContinuousHeadA, sortedContinuousHeadB);
    private _GetCovariance_autogen1(continuousHeadA, continuousHeadB, discrete);
    private _GetCovariance_autogen2(continuousHeadA, continuousHeadB);
    private _GetCovariance_autogen3(continuousHeadA, timeA, continuousHeadB, timeB);
    private _GetCovariance_autogen4(continuousHeadA, continuousHeadB, discrete);
    private _GetCovariance_autogen5(continuousHeadA, timeA, continuousHeadB, timeB, discrete);
    private _GetCovariance_autogen6(continuousHeadA, timeA, continuousHeadB, timeB, discrete);
    private _GetCovariance_autogen7(continuousHeadA, continuousHeadB, discrete);
    private _GetCovariance_autogen8(continuousHeadA, continuousHeadB, discrete);
    private _GetCovariance_autogen9(continuousHeadA, continuousHeadB, iterator);
    private _GetCovariance_autogen10(continuousHeadA, timeA, continuousHeadB, timeB, iterator);
    private _GetCovariance_autogen11(continuousHeadA, continuousHeadB, iterator);
    _ru_x_(p_autogen98: number, p_autogen99: number, p_autogen100: number): number;
    /**
*  Gets the weight (regression coefficient) of the Gaussian distribution at the specified [index] in the {@link com.bayesserver.Table} of discrete combinations.
*
* @param {number} index The index into the discrete table of combinations.  If no discrete variables are present in the distribution, index will always be 0.
*
* @param {number} sortedContinuousHead The position of the required continuous head variable.
*
* @param {number} sortedContinuousTail The position of the required continuous tail variable.

* @return {number} The weight / regression coefficient.
*/
    getWeight(index: number, sortedContinuousHead: number, sortedContinuousTail: number): number;
    /**
*  Gets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The weight/regression coefficient.
*/
    getWeight(continuousHead: Variable, continuousTail: Variable, discrete: State[]): number;
    /**
*  Gets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {?number} timeHead The time of the continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {?number} timeTail The time of the continuous tail variable, or null if not a temporal variable.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The weight/regression coefficient.
*/
    getWeight(continuousHead: Variable, timeHead: number | null, continuousTail: Variable, timeTail: number | null, discrete: State[]): number;
    /**
*  Gets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H|T).
*
* @param {VariableContext} continuousTail A continuous tail variable and time (if any) from T in the expression P(H|T).
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The weight/regression coefficient.
*/
    getWeight(continuousHead: VariableContext, continuousTail: VariableContext, discrete: State[]): number;
    /**
*  Gets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The weight/regression coefficient.
*/
    getWeight(continuousHead: Variable, continuousTail: Variable, discrete: StateContext[]): number;
    /**
*  Gets the weight/regression coefficient of a Gaussian distribution with no discrete variables between the [continuousTail] and [continuousHead].
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).

* @return {number} The weight/regression coefficient.
*/
    getWeight(continuousHead: Variable, continuousTail: Variable): number;
    /**
*  Gets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {?number} timeHead The time of the continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {?number} timeTail The time of the continuous tail variable, or null if not a temporal variable.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The weight/regression coefficient.
*/
    getWeight(continuousHead: Variable, timeHead: number | null, continuousTail: Variable, timeTail: number | null, discrete: StateContext[]): number;
    /**
*  Gets the weight/regression coefficient of a Gaussian distribution with no discrete variables between the [continuousTail] and [continuousHead].
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {?number} timeHead The time of the continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {?number} timeTail The time of the continuous tail variable, or null if not a temporal variable.

* @return {number} The weight/regression coefficient.
*/
    getWeight(continuousHead: Variable, timeHead: number | null, continuousTail: Variable, timeTail: number | null): number;
    /**
*  Gets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H|T).
*
* @param {VariableContext} continuousTail A continuous tail variable and time (if any) from T in the expression P(H|T).
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).

* @return {number} The weight/regression coefficient.
*/
    getWeight(continuousHead: VariableContext, continuousTail: VariableContext, discrete: StateContext[]): number;
    /**
*  Gets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.

* @return {number} The weight/regression coefficient.
*/
    getWeight(continuousHead: Variable, continuousTail: Variable, iterator: TableIterator): number;
    /**
*  Gets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {?number} timeHead The time of the continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {?number} timeTail The time of the continuous tail variable, or null if not a temporal variable.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.

* @return {number} The weight/regression coefficient.
*/
    getWeight(continuousHead: Variable, timeHead: number | null, continuousTail: Variable, timeTail: number | null, iterator: TableIterator): number;
    /**
*  Gets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H|T).
*
* @param {VariableContext} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.

* @return {number} The weight/regression coefficient.
*/
    getWeight(continuousHead: VariableContext, continuousTail: VariableContext, iterator: TableIterator): number;
    private _GetWeight_autogen0(index, sortedContinuousHead, sortedContinuousTail);
    private _GetWeight_autogen1(continuousHead, continuousTail, discrete);
    private _GetWeight_autogen2(continuousHead, timeHead, continuousTail, timeTail, discrete);
    private _GetWeight_autogen3(continuousHead, continuousTail, discrete);
    private _GetWeight_autogen4(continuousHead, continuousTail, discrete);
    private _GetWeight_autogen5(continuousHead, continuousTail);
    private _GetWeight_autogen6(continuousHead, timeHead, continuousTail, timeTail, discrete);
    private _GetWeight_autogen7(continuousHead, timeHead, continuousTail, timeTail);
    private _GetWeight_autogen8(continuousHead, continuousTail, discrete);
    private _GetWeight_autogen9(continuousHead, continuousTail, iterator);
    private _GetWeight_autogen10(continuousHead, timeHead, continuousTail, timeTail, iterator);
    private _GetWeight_autogen11(continuousHead, continuousTail, iterator);
    _rv_x_(p_autogen143: number, p_autogen144: number, p_autogen145: number): number;
    /**
*  Sets the mean value of the Gaussian distribution at the specified [index] in the {@link com.bayesserver.Table} of discrete combinations.
*
* @param {number} index The index into the discrete table of combinations.  If no discrete variables are present in the distribution, index will always be 0.
*
* @param {number} sortedContinuousHead The position of the required continuous head variable.
*
* @param {number} value The mean value.
*/
    setMean(index: number, sortedContinuousHead: number, value: number): void;
    /**
*  Sets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the [discrete] combination.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {number} value The mean value.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setMean(continuousHead: Variable, value: number, discrete: State[]): void;
    /**
*  Sets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the [discrete] combination.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {number} value The mean value.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setMean(continuousHead: Variable, time: number | null, value: number, discrete: State[]): void;
    /**
*  Sets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the [discrete] combination.
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {number} value The mean value.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setMean(continuousHead: VariableContext, value: number, discrete: State[]): void;
    /**
*  Sets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the [discrete] combination.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {number} value The mean value.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setMean(continuousHead: Variable, value: number, discrete: StateContext[]): void;
    /**
*  Sets the mean value of a Gaussian distribution with no discrete variables for the specified [continuousHead] variable.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {number} value The mean value.
*/
    setMean(continuousHead: Variable, value: number): void;
    /**
*  Sets the mean value of a Gaussian distribution with no discrete variables for the specified [continuousHead] variable.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {number} value The mean value.
*/
    setMean(continuousHead: Variable, time: number | null, value: number): void;
    /**
*  Sets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the [discrete] combination.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {number} value The mean value.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setMean(continuousHead: Variable, time: number | null, value: number, discrete: StateContext[]): void;
    /**
*  Sets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the [discrete] combination.
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {number} value The mean value.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setMean(continuousHead: VariableContext, value: number, discrete: StateContext[]): void;
    /**
*  Sets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the discrete combination.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {number} value The mean value.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.
*/
    setMean(continuousHead: Variable, value: number, iterator: TableIterator): void;
    /**
*  Sets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the discrete combination.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {number} value The mean value.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.
*/
    setMean(continuousHead: Variable, time: number | null, value: number, iterator: TableIterator): void;
    /**
*  Sets the mean value of the Gaussian distribution for the specified [continuousHead] variable for the discrete combination.
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {number} value The mean value.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.
*/
    setMean(continuousHead: VariableContext, value: number, iterator: TableIterator): void;
    private _SetMean_autogen0(index, sortedContinuousHead, value);
    private _SetMean_autogen1(continuousHead, value, discrete);
    private _SetMean_autogen2(continuousHead, time, value, discrete);
    private _SetMean_autogen3(continuousHead, value, discrete);
    private _SetMean_autogen4(continuousHead, value, discrete);
    private _SetMean_autogen5(continuousHead, value);
    private _SetMean_autogen6(continuousHead, time, value);
    private _SetMean_autogen7(continuousHead, time, value, discrete);
    private _SetMean_autogen8(continuousHead, value, discrete);
    private _SetMean_autogen9(continuousHead, value, iterator);
    private _SetMean_autogen10(continuousHead, time, value, iterator);
    private _SetMean_autogen11(continuousHead, value, iterator);
    /**
*  Sets the covariance value of the Gaussian distribution at the specified [index] in the {@link com.bayesserver.Table} of discrete combinations.
*
* @param {number} index The index into the discrete table of combinations.  If no discrete variables are present in the distribution, index will always be 0.
*
* @param {number} sortedContinuousHeadA The position of the first continuous head variable.
*
* @param {number} sortedContinuousHeadB The position of the second continuous head variable.
*
* @param {number} value The covariance value to copy.
*/
    setCovariance(index: number, sortedContinuousHeadA: number, sortedContinuousHeadB: number, value: number): void;
    /**
*  Sets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {number} value The covariance value.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setCovariance(continuousHeadA: Variable, continuousHeadB: Variable, value: number, discrete: State[]): void;
    /**
*  Sets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeA The time of the first continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeB The time of the second continuous head variable, or null if not a temporal variable.
*
* @param {number} value The covariance value.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setCovariance(continuousHeadA: Variable, timeA: number | null, continuousHeadB: Variable, timeB: number | null, value: number, discrete: State[]): void;
    /**
*  Sets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHeadA A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {VariableContext} continuousHeadB A second continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {number} value The covariance value.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setCovariance(continuousHeadA: VariableContext, continuousHeadB: VariableContext, value: number, discrete: State[]): void;
    /**
*  Sets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {number} value The covariance value.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setCovariance(continuousHeadA: Variable, continuousHeadB: Variable, value: number, discrete: StateContext[]): void;
    /**
*  Sets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeA The time of the first continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeB The time of the second continuous head variable, or null if not a temporal variable.
*
* @param {number} value The covariance value.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setCovariance(continuousHeadA: Variable, timeA: number | null, continuousHeadB: Variable, timeB: number | null, value: number, discrete: StateContext[]): void;
    /**
*  Sets the covariance of a Gaussian distribution with no discrete variables between [continuousHeadA] and [continuousHeadB]
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeA The time of the first continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeB The time of the second continuous head variable, or null if not a temporal variable.
*
* @param {number} value The covariance value.
*/
    setCovariance(continuousHeadA: Variable, timeA: number | null, continuousHeadB: Variable, timeB: number | null, value: number): void;
    /**
*  Sets the covariance of a Gaussian distribution with no discrete variables between [continuousHeadA] and [continuousHeadB]
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {number} value The covariance value.
*/
    setCovariance(continuousHeadA: Variable, continuousHeadB: Variable, value: number): void;
    /**
*  Sets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHeadA A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {VariableContext} continuousHeadB A second continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {number} value The covariance value.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setCovariance(continuousHeadA: VariableContext, continuousHeadB: VariableContext, value: number, discrete: StateContext[]): void;
    /**
*  Sets the covariance of a Gaussian distribution with no discrete variables between [continuousHeadA] and [continuousHeadB].
*
* @param {VariableContext} continuousHeadA A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {VariableContext} continuousHeadB A second continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {number} value The covariance value.
*/
    setCovariance(continuousHeadA: VariableContext, continuousHeadB: VariableContext, value: number): void;
    /**
*  Sets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {number} value The covariance value.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.
*/
    setCovariance(continuousHeadA: Variable, continuousHeadB: Variable, value: number, iterator: TableIterator): void;
    /**
*  Sets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHeadA A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeA The time of the first continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousHeadB A second continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} timeB The time of the second continuous head variable, or null if not a temporal variable.
*
* @param {number} value The covariance value.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.
*/
    setCovariance(continuousHeadA: Variable, timeA: number | null, continuousHeadB: Variable, timeB: number | null, value: number, iterator: TableIterator): void;
    /**
*  Sets the covariance of the Gaussian distribution between [continuousHeadA] and [continuousHeadB] for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHeadA A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {VariableContext} continuousHeadB A second continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {number} value The covariance value.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.
*/
    setCovariance(continuousHeadA: VariableContext, continuousHeadB: VariableContext, value: number, iterator: TableIterator): void;
    private _SetCovariance_autogen0(index, sortedContinuousHeadA, sortedContinuousHeadB, value);
    private _SetCovariance_autogen1(continuousHeadA, continuousHeadB, value, discrete);
    private _SetCovariance_autogen2(continuousHeadA, timeA, continuousHeadB, timeB, value, discrete);
    private _SetCovariance_autogen3(continuousHeadA, continuousHeadB, value, discrete);
    private _SetCovariance_autogen4(continuousHeadA, continuousHeadB, value, discrete);
    private _SetCovariance_autogen5(continuousHeadA, timeA, continuousHeadB, timeB, value, discrete);
    private _SetCovariance_autogen6(continuousHeadA, timeA, continuousHeadB, timeB, value);
    private _SetCovariance_autogen7(continuousHeadA, continuousHeadB, value);
    private _SetCovariance_autogen8(continuousHeadA, continuousHeadB, value, discrete);
    private _SetCovariance_autogen9(continuousHeadA, continuousHeadB, value);
    private _SetCovariance_autogen10(continuousHeadA, continuousHeadB, value, iterator);
    private _SetCovariance_autogen11(continuousHeadA, timeA, continuousHeadB, timeB, value, iterator);
    private _SetCovariance_autogen12(continuousHeadA, continuousHeadB, value, iterator);
    _sq_x_(p_autogen227: number, p_autogen228: number, p_autogen229: number, p_autogen230: number): void;
    /**
*  Sets the variance value of the Gaussian distribution at the specified [index] in the {@link com.bayesserver.Table} of discrete combinations.
*
* @param {number} index The index into the discrete table of combinations.  If no discrete variables are present in the distribution, index will always be 0.
*
* @param {number} sortedContinuousHead The position of the required continuous head variable.
*
* @param {number} value The variance value to set.
*/
    setVariance(index: number, sortedContinuousHead: number, value: number): void;
    /**
*  Sets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {number} value The variance value.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setVariance(continuousHead: Variable, value: number, discrete: State[]): void;
    /**
*  Sets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {number} value The variance value.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setVariance(continuousHead: Variable, time: number | null, value: number, discrete: State[]): void;
    /**
*  Sets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {number} value The variance value.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setVariance(continuousHead: VariableContext, value: number, discrete: State[]): void;
    /**
*  Sets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {number} value The variance value.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setVariance(continuousHead: Variable, value: number, discrete: StateContext[]): void;
    /**
*  Sets the variance of a Gaussian distribution with no discrete variables for the specified [continuousHead] variable.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {number} value The variance value.
*/
    setVariance(continuousHead: Variable, value: number): void;
    /**
*  Sets the variance of a Gaussian distribution with no discrete variables for the specified [continuousHead] variable.
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {number} value The variance value.
*/
    setVariance(continuousHead: Variable, time: number | null, value: number): void;
    /**
*  Sets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {number} value The variance value.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setVariance(continuousHead: Variable, time: number | null, value: number, discrete: StateContext[]): void;
    /**
*  Sets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {number} value The variance value.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setVariance(continuousHead: VariableContext, value: number, discrete: StateContext[]): void;
    /**
*  Sets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {number} value The variance value.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.
*/
    setVariance(continuousHead: Variable, value: number, iterator: TableIterator): void;
    /**
*  Sets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H) or P(H|T).
*
* @param {?number} time The time of the continuous head variable, or null if not a temporal variable.
*
* @param {number} value The variance value.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.
*/
    setVariance(continuousHead: Variable, time: number | null, value: number, iterator: TableIterator): void;
    /**
*  Sets the variance of the Gaussian distribution for the specified [continuousHead] variable for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHead A continuous head variable and time (if any) from H in the expression P(H) or P(H|T).
*
* @param {number} value The variance value.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.
*/
    setVariance(continuousHead: VariableContext, value: number, iterator: TableIterator): void;
    private _SetVariance_autogen0(index, sortedContinuousHead, value);
    private _SetVariance_autogen1(continuousHead, value, discrete);
    private _SetVariance_autogen2(continuousHead, time, value, discrete);
    private _SetVariance_autogen3(continuousHead, value, discrete);
    private _SetVariance_autogen4(continuousHead, value, discrete);
    private _SetVariance_autogen5(continuousHead, value);
    private _SetVariance_autogen6(continuousHead, time, value);
    private _SetVariance_autogen7(continuousHead, time, value, discrete);
    private _SetVariance_autogen8(continuousHead, value, discrete);
    private _SetVariance_autogen9(continuousHead, value, iterator);
    private _SetVariance_autogen10(continuousHead, time, value, iterator);
    private _SetVariance_autogen11(continuousHead, value, iterator);
    _sr_x_(p_autogen287: number, p_autogen288: number, p_autogen289: number): void;
    /**
*  Sets the weight/regression coefficient of the Gaussian distribution at the specified [index] in the {@link com.bayesserver.Table} of discrete combinations.
*
* @param {number} index The index into the discrete table of combinations.  If no discrete variables are present in the distribution, index will always be 0.
*
* @param {number} sortedContinuousHead The position of the required continuous head variable.
*
* @param {number} sortedContinuousTail The position of the required continuous tail variable.
*
* @param {number} value The weight to copy.
*/
    setWeight(index: number, sortedContinuousHead: number, sortedContinuousTail: number, value: number): void;
    /**
*  Sets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {number} value The weight/regression coefficient.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setWeight(continuousHead: Variable, continuousTail: Variable, value: number, discrete: State[]): void;
    /**
*  Sets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {?number} timeHead The time of the continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {?number} timeTail The time of the continuous tail variable, or null if not a temporal variable.
*
* @param {number} value The weight/regression coefficient.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setWeight(continuousHead: Variable, timeHead: number | null, continuousTail: Variable, timeTail: number | null, value: number, discrete: State[]): void;
    /**
*  Sets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHead A continuous head variable and associated time (if any) from H in the expression P(H|T).
*
* @param {VariableContext} continuousTail A continuous tail variable and associated time (if any) from T in the expression P(H|T).
*
* @param {number} value The weight/regression coefficient.
*
* @param {State[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setWeight(continuousHead: VariableContext, continuousTail: VariableContext, value: number, discrete: State[]): void;
    /**
*  Sets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {number} value The weight/regression coefficient.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setWeight(continuousHead: Variable, continuousTail: Variable, value: number, discrete: StateContext[]): void;
    /**
*  Sets the weight/regression coefficient of a Gaussian distribution with no discrete variables between the [continuousTail] and [continuousHead].
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {number} value The weight/regression coefficient.
*/
    setWeight(continuousHead: Variable, continuousTail: Variable, value: number): void;
    /**
*  Sets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {?number} timeHead The time of the continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {?number} timeTail The time of the continuous tail variable, or null if not a temporal variable.
*
* @param {number} value The weight/regression coefficient.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setWeight(continuousHead: Variable, timeHead: number | null, continuousTail: Variable, timeTail: number | null, value: number, discrete: StateContext[]): void;
    /**
*  Sets the weight/regression coefficient of a Gaussian distribution with no discrete variables between the [continuousTail] and [continuousHead].
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {?number} timeHead The time of the continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {?number} timeTail The time of the continuous tail variable, or null if not a temporal variable.
*
* @param {number} value The weight/regression coefficient.
*/
    setWeight(continuousHead: Variable, timeHead: number | null, continuousTail: Variable, timeTail: number | null, value: number): void;
    /**
*  Sets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHead A continuous head variable and associated time (if any) from H in the expression P(H|T).
*
* @param {VariableContext} continuousTail A continuous tail variable and associated time (if any) from T in the expression P(H|T).
*
* @param {number} value The weight/regression coefficient.
*
* @param {StateContext[]} discrete The discrete combination (mixture).  Can be empty if this distribution has no discrete variables (i.e. the Gaussian is not a mixture of Gaussians).
*/
    setWeight(continuousHead: VariableContext, continuousTail: VariableContext, value: number, discrete: StateContext[]): void;
    /**
*  Sets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {number} value The weight/regression coefficient.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.
*/
    setWeight(continuousHead: Variable, continuousTail: Variable, value: number, iterator: TableIterator): void;
    /**
*  Sets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {Variable} continuousHead A continuous head variable from H in the expression P(H|T).
*
* @param {?number} timeHead The time of the continuous head variable, or null if not a temporal variable.
*
* @param {Variable} continuousTail A continuous tail variable from T in the expression P(H|T).
*
* @param {?number} timeTail The time of the continuous tail variable, or null if not a temporal variable.
*
* @param {number} value The weight/regression coefficient.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.
*/
    setWeight(continuousHead: Variable, timeHead: number | null, continuousTail: Variable, timeTail: number | null, value: number, iterator: TableIterator): void;
    /**
*  Sets the weight/regression coefficient of the Gaussian distribution between the [continuousTail] and [continuousHead] for a particular discrete combination (mixture).
*
* @param {VariableContext} continuousHead A continuous head variable and associated time (if any) from H in the expression P(H|T).
*
* @param {VariableContext} continuousTail A continuous tail variable and associated time (if any) from T in the expression P(H|T).
*
* @param {number} value The weight/regression coefficient.
*
* @param {TableIterator} iterator The discrete combination (mixture) identified by the position of the iterator.
*/
    setWeight(continuousHead: VariableContext, continuousTail: VariableContext, value: number, iterator: TableIterator): void;
    private _SetWeight_autogen0(index, sortedContinuousHead, sortedContinuousTail, value);
    private _SetWeight_autogen1(continuousHead, continuousTail, value, discrete);
    private _SetWeight_autogen2(continuousHead, timeHead, continuousTail, timeTail, value, discrete);
    private _SetWeight_autogen3(continuousHead, continuousTail, value, discrete);
    private _SetWeight_autogen4(continuousHead, continuousTail, value, discrete);
    private _SetWeight_autogen5(continuousHead, continuousTail, value);
    private _SetWeight_autogen6(continuousHead, timeHead, continuousTail, timeTail, value, discrete);
    private _SetWeight_autogen7(continuousHead, timeHead, continuousTail, timeTail, value);
    private _SetWeight_autogen8(continuousHead, continuousTail, value, discrete);
    private _SetWeight_autogen9(continuousHead, continuousTail, value, iterator);
    private _SetWeight_autogen10(continuousHead, timeHead, continuousTail, timeTail, value, iterator);
    private _SetWeight_autogen11(continuousHead, continuousTail, value, iterator);
    _ss_x_(p_autogen329: number, p_autogen330: number, p_autogen331: number, p_autogen332: number): void;
    /**
*  Gets the collection of variables in the distribution, sorted by time (which may be null) and the order in which variables were created.

* @return {VariableContextCollection} Variables sorted by time and the order in which variables were created.
*/
    readonly sortedVariables: VariableContextCollection;
    /**
*  Gets the collection of continuous head variables in the distribution, sorted by time (which may be null) and the order in which variables were created.
*
* Note that head variables are those that appear to the left of the bar in the expression P(A|B) and tail variables are those to the right.

* @return {VariableContextCollection} Continuous head variables sorted by time, and the order in which variables were created.

* @see com.bayesserver.VariableMap
*/
    readonly sortedContinuousHead: VariableContextCollection;
    /**
*  Gets the collection of continuous tail variables in the distribution, sorted by time (which may be null) and the order in which variables were created.
*
* Note that head variables are those that appear to the left of the bar in the expression P(A|B) and tail variables are those to the right.

* @return {VariableContextCollection} Continuous tail variables sorted by time and the order in which variables were created.

* @see com.bayesserver.VariableMap
*/
    readonly sortedContinuousTail: VariableContextCollection;
    /**
*  Gets the current owner, if assigned to a node.  A distribution cannot be modified when it is assigned to a node.

* @return {Node} The owner, or null if not assigned to a node.
*/
    readonly owner: Node;
    _setOwner(value: Node): void;
    readonly outer: IDistribution;
    /**
*  Gets the {@link com.bayesserver.Table} which specifies the distribution over any discrete variables.

* @return {Table} The table.
*/
    readonly table: Table;
    /**
*  Copies the values from the [source] distribution to this instance.  The variable counts between distributions must match but the variable contexts need not be equal.
*
* @param {CLGaussian} source The source distribution from which values are copied.
*/
    copyFrom(source: CLGaussian): void;
    /**
*  Creates a new distribution by dividing this instance by the [subset].  Also known as the complement.
*
* If the resulting distribution were subsequently multiplied by [subset], the result would be equivalent to this instance.
*
* @param {IDistribution} subset The subset to divide by.

* @return {IDistribution} The new distribution (complement).

* @exception ReferenceError Raised if [subset] is null.

* @exception Error If subset is not a subset of variables in this instance.
*/
    divide(subset: IDistribution): IDistribution;
    /**
*  Creates a new distribution by dividing this instance by the [subset].  Also known as the complement.
*
* If the resulting distribution were subsequently multiplied by [subset], the result would be equivalent to this instance.
*
* @param {CLGaussian} subset The subset to divide by.

* @return {CLGaussian} The new distribution (complement).

* @exception ReferenceError Raised if [subset] is null.

* @exception Error If subset is not a subset of variables in this instance.
*/
    divide(subset: CLGaussian): CLGaussian;
    private _Divide_autogen0(subset);
    private _Divide_autogen1(subset);
    private _sv_x_(p_autogen391, p_autogen392);
    /**
*  Instantiates discrete variables.
*
* @param {?number[]} discreteValues A discrete value (or null) for each discrete variable in the Gaussian table.

* @return {CLGaussian} The instantiated distribution.
*/
    instantiateDiscrete(discreteValues: (number | null)[]): CLGaussian;
    /**
*  Calculates the distribution which results from instantiating a number of variables.
*
* [values] should contain one entry for each
* @see com.bayesserver.VariableContext
in the distribution, however entries can be null.
*
* @param {?number[]} values The instantiated values. Entries can be null.

* @return {IDistribution} The instantiated distribution.
*/
    instantiate(values: (number | null)[]): IDistribution;
    /**
*  Calculates the distribution which results from instantiating a particular variable.
*
* @param {Variable} variable The variable to instantiate.
*
* @param {number} value The instantiated value.

* @return {CLGaussian} The instantiated distribution.

* @exception ReferenceError Raised if [variable] is null.
*/
    instantiate(variable: Variable, value: number): CLGaussian;
    /**
*  Calculates the distribution which results from instantiating a particular variable at a specified time.
*
* @param {Variable} variable The variable to instantiate.
*
* @param {number} value The instantiated value.
*
* @param {?number} time The time associated with the variable. Can be null.

* @return {CLGaussian} The instantiated distribution.

* @exception ReferenceError Raised if [variable] is null.
*/
    instantiate(variable: Variable, value: number, time: number | null): CLGaussian;
    private _Instantiate_autogen0(values);
    private _Instantiate_autogen1(variable, value);
    private _Instantiate_autogen2(variable, value, time);
    /**
*  Instantiates continuous head variable contexts.
*
* @param {?number[]} headValues The value (or null) for each continuous head variable context.
*
* @param {number[]} logPdf Optional array of length {@link com.bayesserver.Table#size} that is filled with the logged pdf values, useful when pdf values are zero.

* @return {IDistribution} The instantiated distribution.
*/
    instantiateHeads(headValues: (number | null)[], logPdf: number[]): IDistribution;
    /**
*  Calculates the distribution which results from instantiating continuous tail variables.
*
* @param {?number[]} tailValues The value (or null) for each continuous tail.

* @return {CLGaussian} The instantiated distribution.
*/
    instantiateTails(tailValues: (number | null)[]): CLGaussian;
    private _tu_x_(p_autogen417, p_autogen418, p_autogen419);
    /**
*  Calculates the distribution which results from instantiating a particular continuous head variable at a specified time.
*
* @param {Variable} variable The variable to instantiate.
*
* @param {number} value The instantiated value.
*
* @param {?number} time The time associated with the variable. Can be null.

* @return {CLGaussian} The instantiated distribution.

* @exception ReferenceError Raised if [variable] is null.
*/
    instantiateHead(variable: Variable, value: number, time: number | null): CLGaussian;
    /**
*  Calculates the distribution which results from instantiating a particular continuous head variable at a specified time.
*
* @param {Variable} variable The variable to instantiate.
*
* @param {number} value The instantiated value.
*
* @param {?number} time The time associated with the variable. Can be null.
*
* @param {number[]} logPdf A buffer of length {@link com.bayesserver.Table#size}that is filled with the log of the pdf values calculated during instantiation. Can be null.

* @return {CLGaussian} The instantiated distribution.

* @exception ReferenceError Raised if [variable] is null.
*/
    instantiateHead(variable: Variable, value: number, time: number | null, logPdf: number[]): CLGaussian;
    /**
*  Instantiates all continuous head variable contexts.
*
* @param {number[]} headValues The values for the continuous head variable contexts.
*
* @param {number[]} logPdf Optional array of length {@link com.bayesserver.Table#size} that is filled with the logged pdf values, useful when pdf values are zero.

* @return {Table} The instantiated distribution.
*/
    instantiateHead(headValues: number[], logPdf: number[]): Table;
    private _InstantiateHead_autogen0(variable, value, time);
    private _InstantiateHead_autogen1(variable, value, time, logPdf);
    private _InstantiateHead_autogen2(headValues, logPdf);
    private _tv_x_(p_autogen429, p_autogen430, p_autogen431);
    private _uq_x_(p_autogen432, p_autogen433, p_autogen434);
    /**
*  Marginalizes (integrates) the [superset] into this instance.
*
* @param {IDistribution} superset A distribution whose variables form a superset of the variables in this instance.

* @exception ReferenceError Raised if [superset] is null.

* @exception Error Raised if this instance is read only, or if any variables are no longer correctly due to modifications of the network.

* @exception Error Raised if [superset] does not contain all the variables in this instance.
*/
    marginalize(superset: IDistribution): void;
    /**
*  Marginalizes (integrates) the [superset] into this instance.
*
* @param {IDistribution} superset A distribution whose variables form a superset of the variables in this instance.
*
* @param {PropagationMethod} propagation The propagation method to use during marginalization.

* @exception ReferenceError Raised if [superset] is null.

* @exception Error Raised if this instance is read only, or if any variables are no longer correctly due to modifications of the network.

* @exception Error Raised if [superset] does not contain all the variables in this instance.
*/
    marginalize(superset: IDistribution, propagation: PropagationMethod): void;
    /**
*  Marginalizes (sums/integrates) the [superset] into this instance.
*
* @param {CLGaussian} superset A {@link com.bayesserver.CLGaussian} whose variables form a superset of the variables in this instance.

* @exception ReferenceError Raised if [superset] is null.

* @exception Error Raised if this instance is read only, or if any variables are no longer sorted correctly due to modifications of the network.

* @exception Error Raised if [superset] does not contain all the variables in this instance.
*/
    marginalize(superset: CLGaussian): void;
    private _Marginalize_autogen0(superset);
    private _Marginalize_autogen1(superset, propagation);
    private _Marginalize_autogen2(superset);
    /**
*  Marginalizes (sums/integrates) out all continuous variables from this instance into the specified table.
*
* @param {Table} table A {@link com.bayesserver.Table} whose variables form a subset of discrete variables in this instance.

* @exception ReferenceError Raised if [table] is null.
*/
    marginalizeTo(table: Table): void;
    /**
*  Marginalizes (sums/integrates) out all continuous variables from this instance into the specified table.
*
* @param {Table} table A {@link com.bayesserver.Table} whose variables form a subset of discrete variables in this instance.
*
* @param {PropagationMethod} propagation The propagation method to use during marginalization.

* @exception ReferenceError Raised if [table] is null.
*/
    marginalizeTo(table: Table, propagation: PropagationMethod): void;
    private _MarginalizeTo_autogen0(table);
    private _MarginalizeTo_autogen1(table, propagation);
    private _us_x_(p_autogen446, p_autogen447, p_autogen448);
    /**
*  Multiplies this instance by another {@link com.bayesserver.CLGaussian} distribution.
*
* @param {CLGaussian} gaussian The distribution to combine.

* @return {CLGaussian} The combined distribution.

* @exception ReferenceError Raised if [gaussian] is null.
*/
    multiply(gaussian: CLGaussian): CLGaussian;
    /**
*  Multiplies this instance by another distribution.
*
* @param {IDistribution} distribution The distribution to combine.

* @return {IDistribution} The combined distribution.

* @exception ReferenceError Raised if [distribution] is null.
*/
    multiply(distribution: IDistribution): IDistribution;
    private _Multiply_autogen0(gaussian);
    private _Multiply_autogen1(distribution);
    private _vq_x_(p_autogen458, p_autogen459);
    _vu_x_(p_autogen467: number, p_autogen468: string, p_autogen469: boolean): boolean;
    private _vv_x_(p_autogen470, p_autogen471, p_autogen472);
    private static _v_x_(p_autogen26, p_autogen27);
    private static _rq_x_(p_autogen36, p_autogen37);
    private static _st_x_(p_autogen383, p_autogen384);
    private static _su_x_(p_autogen387, p_autogen388, p_autogen389);
    private static _tq_x_(p_autogen396, p_autogen397);
    private static _tr_x_(p_autogen401, p_autogen402, p_autogen403, p_autogen404);
    private static _ts_x_(p_autogen406, p_autogen407, p_autogen408);
    private static _tt_x_(p_autogen414, p_autogen415, p_autogen416);
    private static _ur_x_(p_autogen435, p_autogen436, p_autogen437, p_autogen438);
    private static _ut_x_(p_autogen449, p_autogen450, p_autogen451);
    private static _uu_x_(p_autogen452, p_autogen453);
    private static _uv_x_(p_autogen456, p_autogen457);
    private static _vr_x_(p_autogen460, p_autogen461, p_autogen462);
    private static _vs_x_(p_autogen463, p_autogen464);
    private static _vt_x_(p_autogen465, p_autogen466);
}
/**
*  Specifies how the collection is changed.
*/
export declare class CollectionAction {
    /**
*  Specifies that an element was added to the collection.
*/
    static readonly Insert: CollectionAction;
    /**
*  Specifies that an element was removed from the collection.
*/
    static readonly Remove: CollectionAction;
    /**
*  Specifies that an element was replaced in the collection.
*/
    static readonly Replace: CollectionAction;
    /**
*  Specifies that the entire collection has been cleared.
*/
    static readonly Clear: CollectionAction;
}
/**
*  Stores a custom property.
*/
export declare class CustomProperty {
    private _Ea_x_;
    private _Eb_x_;
    private _Ec_x_;
    private _Ed_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.CustomProperty} class.
*
* @param {string} name The name of the custom property, which must be unique per {@link com.bayesserver.CustomPropertyCollection}.
*/
    constructor(name: string);
    /**
*  Initializes a new instance of the {@link com.bayesserver.CustomProperty} class.
*
* @param {string} name The name of the custom property, which must be unique per {@link com.bayesserver.CustomPropertyCollection}.
*
* @param {string} value The custom value.
*/
    constructor(name: string, value: string);
    private _cons_autogen0(name);
    private _cons_autogen1(name, value);
    private _rqt_x_(p_autogen3, p_autogen4);
    /**
*  Makes a copy of this instance.

* @return {CustomProperty} The copy.
*/
    copy(): CustomProperty;
    /**
*  Gets the name, which must be unique per {@link com.bayesserver.CustomPropertyCollection}.
*/
    readonly name: string;
    /**
*  The custom property value.  E.g. an XML string.
*/
    /**
*  The custom property value.  E.g. an XML string.
*/
    value: string;
    /**
*  An optional description for the custom property.
*/
    /**
*  An optional description for the custom property.
*/
    description: string;
    /**
*  Gets the parent collection, if set, otherwise null.
*/
    readonly parent: CustomPropertyCollection;
    _setParent(value: CustomPropertyCollection): void;
}
/**
*  Stores custom properties for a variety of objects.
*/
export declare class CustomPropertyCollection implements IList<CustomProperty> {
    private _Ee_x_;
    private _items;
    private _Ef_x_;
    constructor(p_autogen0: any);
    /**
* @inheritDoc
*/
    _2ad2e5f4b2884a52bf8bfc07ce8953d3(): void;
    /**
*  Gets the instance that these custom properties belong to.
*/
    readonly owner: any;
    /**
*  Gets the {@link com.bayesserver.CustomProperty} with the specified name, from the collection, or returns null if not found.
*
* @param {string} name The name of the {@link com.bayesserver.CustomProperty} to return.

* @return {CustomProperty} The {@link com.bayesserver.CustomProperty} with the specified name, or null if not found.
*/
    get(name: string): CustomProperty;
    get(index: number): CustomProperty;
    private _get_autogen0(name);
    private _get_autogen1(index);
    /**
* @inheritDoc
*/
    clear(): void;
    [Symbol.iterator](): Iterator<CustomProperty>;
    /**
* @inheritDoc
*/
    removeAt(index: number): CustomProperty;
    /**
* @inheritDoc
*/
    insert(index: number, element: CustomProperty): void;
    set(index: number, element: CustomProperty): CustomProperty;
    readonly size: number;
    includes(item: CustomProperty): boolean;
    push(...items: CustomProperty[]): number;
    indexOf(item: CustomProperty): number;
    remove(item: CustomProperty): boolean;
}
/**
*  Includes methods for testing whether a network is a Directed Acyclic Graph (DAG).

* @see com.bayesserver.Network#isDag
*/
export declare class Dag {
    /**
*  Determines if a network is a Directed Acyclic Graph (DAG).
*
* @param {Network} network The network to test.

* @return {boolean} <code>true</code> if a dag, <code>false</code> otherwise.

* @see com.bayesserver.Network#isDag
*/
    static isDag(network: Network): boolean;
    /**
*  Determines if a network is a DAG (Directed Acyclic Graph).
*
* The test allows the exclusion of certain links, and the inclusion of extra links that have not yet been added to the network.
*
* @param {Network} network The network to test.
*
* @param {Iterable<Link>} ignore Optional links to ignore.  Can be null.
*
* @param {Iterable<Link>} extra Optional extra links to include. Can be null.

* @return {boolean} <code>true</code> if a dag, <code>false</code> otherwise.

* @see com.bayesserver.Network#isDag
*/
    static isDag(network: Network, ignore: Iterable<Link>, extra: Iterable<Link>): boolean;
    private static _IsDag_autogen0(network);
    private static _IsDag_autogen1(network, ignore, extra);
}
/**
*  Options used by the {@link com.bayesserver.Decomposer} class.
*/
export declare class DecomposeOptions {
    private _Eg_x_;
    private _Eh_x_;
    /**
*  The gap between decomposed nodes, used when laying out new nodes.
*/
    /**
*  The gap between decomposed nodes, used when laying out new nodes.
*/
    gap: number;
    /**
*  Gets a value that can be used to override the width of nodes, used when laying out new nodes.

* @return {?number} Value to override node widths.
*/
    /**
*  Sets a value that can be used to override the width of nodes, used when laying out new nodes.
*
* @param {?number} value Value to override node widths.
*/
    nodeWidthOverride: number | null;
}
/**
*  Contains information returned by {@link com.bayesserver.Decomposer#decompose}.
*/
export declare class DecomposeOutput {
    private _Fa_x_;
    private _Fb_x_;
    private _Fc_x_;
    constructor(p_autogen0: Network, p_autogen1: Network, p_autogen2: Map<Variable, Variable>);
    /**
*  Gets the original network, containing nodes with multiple variables.

* @return {Network} The original network.
*/
    readonly originalNetwork: Network;
    /**
*  Gets the network, which is the decomposed equivalent of the original network.

* @return {Network} The decomposed network.
*/
    readonly decomposedNetwork: Network;
    /**
*  Maps a variable in the decomposed network to the equivalent variable in the original network.
*
* @param {Variable} decomposedVariable The variable in the decomposed network.

* @return {Variable} The equivalent variable in the original network.
*/
    getOriginalVariable(decomposedVariable: Variable): Variable;
    /**
*  Maps a variable in the original network to the equivalent variable in the decomposed network.
*
* @param {Variable} networkVariable The variable in the original network.

* @return {Variable} The equivalent variable in the decomposed network.
*/
    getDecomposedVariable(networkVariable: Variable): Variable;
}
/**
*  Contains methods to decompose nodes with multiple variables into their single variable equivalents.
*/
export declare class Decomposer {
    /**
*  Decomposes a Bayesian network containing nodes with multiple variables into its single variable node equivalent.
*
* @param {Network} network The network containing nodes with multiple variables.
*
* @param {DecomposeOptions} options Options that govern the decomposition.

* @return {DecomposeOutput} The equivalent single variable node Bayesian network.
*/
    static decompose(network: Network, options: DecomposeOptions): DecomposeOutput;
    private static _rqv_x_(p_autogen2, p_autogen3, p_autogen4);
    private static _rrq_x_(p_autogen5, p_autogen6, p_autogen7);
    private static _rrr_x_(p_autogen8, p_autogen9, p_autogen10);
    private static _rrs_x_(p_autogen11, p_autogen12, p_autogen13);
}
/**
*  Identifies a distribution and its temporal order.
*/
export declare class DistributionOrder {
    private _Fg_x_;
    private _Fh_x_;
    constructor(p_autogen0: IDistribution, p_autogen1: number);
    /**
*  Gets the distribution.
*/
    readonly distribution: IDistribution;
    /**
*  Gets the temporal order of the distribution.
*/
    readonly temporalOrder: number;
}
/**
*  Indicates whether a variable is marked as head or tail in a distribution.  See {@link com.bayesserver.VariableContext}.
*
*  Head variables are those on the left, and tail variables are those on the right in the expression P(A|B).

* @see com.bayesserver.VariableContext
*/
export declare class HeadTail {
    /**
*  Indicates that a variable is marked as head in a distribution.  See {@link com.bayesserver.VariableContext}.
*
*  Head variables are those on the left, and tail variables are those on the right in the expression P(A|B).
*/
    static readonly Head: HeadTail;
    /**
*  Indicates that a variable is marked as tail in a distribution.  See {@link com.bayesserver.VariableContext}.
*
*  Head variables are those on the left, and tail variables are those on the right in the expression P(A|B).
*/
    static readonly Tail: HeadTail;
}
/**
*  Interface for cancelling long running operations.
*/
export interface ICancellation {
    cancel: boolean;
}
/**
*  Interface specifying the required methods and properties for a probability distribution.  For example the {@link com.bayesserver.Table} class implements this interface.
*
* While a distribution is assigned to a {@link com.bayesserver.Node} it cannot be modified.

* @see com.bayesserver.Table

* @see com.bayesserver.CLGaussian
*/
export interface IDistribution {
    _39d9d5f7317c4bb79bd3c1e43b2b4a43: string | null;
    sortedVariables: VariableContextCollection;
    timeShift(units: number): void;
    locked: boolean;
    isReadOnly(): boolean;
    owner: Node;
    outer: IDistribution;
    multiply(distribution: IDistribution): IDistribution;
    divide(subset: IDistribution): IDistribution;
    instantiate(values: (number | null)[]): IDistribution;
    marginalize(superset: IDistribution): void;
    marginalize(superset: IDistribution, propagation: PropagationMethod): void;
    copy(): IDistribution;
    copy(timeShift: number | null): IDistribution;
    table: Table;
}
/**
*  For internal use.
*/
export interface INetworkMonitor {
    nodeCollectionChange(index: number, add: Node, remove: Node, action: CollectionAction, complete: boolean): void;
    variableCollectionChange(index: number, add: Variable, remove: Variable, action: CollectionAction, complete: boolean): void;
    linkCollectionChange(index: number, add: Link, remove: Link, action: CollectionAction, complete: boolean): void;
    statesCollectionChange(variable: Variable, index: number, add: State, remove: State, action: CollectionAction, complete: boolean): void;
    distributionChanged(node: Node, key: NodeDistributionKey, kind: NodeDistributionKind, newDistribution: IDistribution, oldDistribution: IDistribution): void;
    noisyNodeTypeChanged(node: Node, newNoisyType: NoisyType, oldNoisyType: NoisyType): void;
    noisyOrderChanged(link: Link, newNoisyOrder: NoisyOrder, oldNoisyOrder: NoisyOrder): void;
}
/**
*  An interval, defined by a minimum and maximum with respective open or closed endpoints.
*
* @param <T>  The data type used in the interval.  E.g. {@link Double}.
*/
export declare class Interval<T> {
    private _Bba_x_;
    private _Bbb_x_;
    private _Bbc_x_;
    private _Bbd_x_;
    /**
*  Initializes a new instance of an Interval.
*
* @param {T} minimum The minimum value in the interval.
*
* @param {T} maximum The maximum value in the interval.
*
* @param {IntervalEndPoint} minimumEndPoint The end point type for the minimum value.
*
* @param {IntervalEndPoint} maximumEndPoint The end point type for the maximum value.
*/
    constructor(minimum: T, maximum: T, minimumEndPoint: IntervalEndPoint, maximumEndPoint: IntervalEndPoint);
    constructor();
    private _cons_autogen0(minimum, maximum, minimumEndPoint, maximumEndPoint);
    private _cons_autogen1();
    /**
*  Gets the maximum interval value.

* @return {T}  The maximum value in the interval.
*/
    /**
*  Sets the maximum interval value.
*
* @param {T} value  The maximum value in the interval.
*/
    maximum: T;
    /**
*  Gets the end point type for the maximum value of the interval.
*/
    /**
*  Sets the end point type for the maximum value of the interval.
*/
    maximumEndPoint: IntervalEndPoint;
    /**
*  Gets the minimum interval value.

* @return {T}  The minimum value in the interval.
*/
    /**
*  Sets the minimum interval value.
*
* @param {T} value  The minimum value in the interval.
*/
    minimum: T;
    /**
*  Gets the end point type for the minimum value of the interval.
*/
    /**
*  Sets the end point type for the minimum value of the interval.
*/
    minimumEndPoint: IntervalEndPoint;
    /**
*  Determines whether a value is within this interval.
*
* @param {T} value The value to check.

* @return {boolean} <code>true</code> if the value is contained in the interval, <code>false</code> otherwise.
*/
    contains(value: T): boolean;
    /**
* @inheritDoc
*/
    compareTo(value: T): number;
    /**
* @inheritDoc
*/
    toString(): string;
    private static _compareTo<T>(a, b);
    private static _valueToString<U>(value);
}
/**
*  The type of end point for an interval.
*/
export declare class IntervalEndPoint {
    /**
*  The end point of an interval is open.
*/
    static readonly Open: IntervalEndPoint;
    /**
*  The end point of an interval is closed.
*/
    static readonly Closed: IntervalEndPoint;
}
/**
*  Raised when a network has not been correctly specified.

* @see com.bayesserver.Network#validate
*/
export declare class InvalidNetworkError extends Error {
    /**
    *  Initializes a new instance of the {@link InvalidNetworkError} class.
    */
    constructor();
    /**
    *  Initializes a new instance of the {@link InvalidNetworkError} class with a specified error message.
    *
    * @param message The error message that explains the reason for the exception.
    */
    constructor(message: string);
}
/**
*  Interface to allow early completion of a long running task.
*
*  Note that while {@link com.bayesserver.IStop} will finish the process (for example in a reduced number of iterations),{@link com.bayesserver.ICancellation} will cancel the learning process, throwing an {@link Error}.
*/
export interface IStop {
    stop: boolean;
}
/**
*  Represents a directed link in a Bayesian network.
*
* For Dynamic Bayesian Networks, an order can be specified to link temporal nodes between different time slices.
*/
export declare class Link {
    private _Bbe_x_;
    private _Bbf_x_;
    private _Bbg_x_;
    private _Bbh_x_;
    private _Bca_x_;
    private _Bcb_x_;
    private _Bcc_x_;
    private _Bcd_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.Link} class with the parent node specified in [from] and the child in [to].
*
* @param {Node} from The parent node.
*
* @param {Node} to The child node.

* @exception ReferenceError Raised if either [from] or [to] is null.
*/
    constructor(from: Node, to: Node);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Link} class with a specified [temporalOrder], the parent node specified in [from] and the child in [to].
*
*  If a temporal order is specified that is greater than zero, then a link can connect two nodes (which may be the same) at different times.
*
* @param {Node} from The parent node.
*
* @param {Node} to The child node.
*
* @param {number} temporalOrder The temporal order.  Must be greater than or equal to zero.

* @exception ReferenceError Raised if either [from] or [to] is null.

* @exception Error Raised if [temporalOrder] is negative.
*/
    constructor(from: Node, to: Node, temporalOrder: number);
    private _cons_autogen0(from, to);
    private _cons_autogen1(from, to, temporalOrder);
    /**
*  Creates a new link, copying the properties from this instance, such as {@link com.bayesserver.Link#getDescription} and {@link com.bayesserver.Link#getCustomProperties}.
*
* @param {Node} from The parent node.
*
* @param {Node} to The child node.
*
* @param {number} temporalOrder The temporal order.  Must be greater than or equal to zero.

* @return {Link} A new link instance.
*/
    copy(from: Node, to: Node, temporalOrder: number): Link;
    /**
*  Gets custom properties associated with this instance.
*
*  Custom properties allow storage of custom information, which will be saved with the network.
*/
    readonly customProperties: CustomPropertyCollection;
    private _rvs_x_(p_autogen8, p_autogen9, p_autogen10);
    _rvt_x_(): void;
    /**
*  The Index of this instance in the collection of links belonging to a network, or -1 if the link does not belong to a network.
*/
    readonly index: number;
    _setIndex(value: number): void;
    /**
*  Optional description for the link.
*/
    /**
*  Optional description for the link.
*/
    description: string;
    /**
*  Gets the temporal order of the link.  If the link is not temporal, zero will be returned.
*/
    readonly temporalOrder: number;
    private _setTemporalOrder(value);
    /**
*  Gets a value which determines the nature of the causal effect between the parent node (from) and a noisy child node (to).
*
*  This property has no effect if the child node is not a noisy node.
*/
    /**
*  Sets a value which determines the nature of the causal effect between the parent node (from) and a noisy child node (to).
*
*  This property has no effect if the child node is not a noisy node.
*/
    noisyOrder: NoisyOrder;
    /**
*  The parent node of the directed link.
*/
    readonly from: Node;
    /**
*  The child node of the directed link.
*/
    readonly to: Node;
    /**
*  The {@link com.bayesserver.Network} the link belongs to.  Value will be null unless the link has been added to a network.
*/
    readonly network: Network;
    _setNetwork(value: Network): void;
}
/**
*  Options controlling {@link com.bayesserver.Table#marginalizeLowMemory}.
*/
export declare class MarginalizeLowMemoryOptions {
    private _Bee_x_;
    private _Bef_x_;
    /**
*  Used to cancel a long running operation.
*/
    /**
*  Used to cancel a long running operation.
*/
    cancellation: ICancellation;
    /**
*  Gets the propagation method to use during marginalization.
*/
    /**
*  Sets the propagation method to use during marginalization.
*/
    propagation: PropagationMethod;
}
/**
*  Provides methods to iterate over multiple distributions.
*/
export declare class MultipleIterator {
    /**
*  Iterates over all the variables and their states found in [subsets].
*
* At each iteration [combination] is called, and [subsetRows] contains the equivalent row in each subset.
*
* @param {VariableContextCollection[]} subsets The distribution to iterate over.
*
* @param {number[]} subsetRows Contains the equivalent row in each subset at a particular iteration (combination).
*
* @param {Action} combination A method which is called for each iteration.
*/
    static iterate(subsets: VariableContextCollection[], subsetRows: number[], combination: () => void): void;
    /**
*  Iterates over all the variables and their states found in [subsets].
*
* At each iteration [combination] is called, and [subsetRows] contains the equivalent row in each subset.
*
* @param {VariableContextCollection} supersetVariables The collection of unique variables (and maybe times) contained in the subsets.
*
* @param {VariableContextCollection[]} subsets The distribution who want to iterate over.
*
* @param {number[]} subsetRows Contains the equivalent row in each subset at a particular iteration (combination).
*
* @param {Action} combination A method which is called for each iteration.
*/
    static iterate(supersetVariables: VariableContextCollection, subsets: VariableContextCollection[], subsetRows: number[], combination: () => void): void;
    private static _Iterate_autogen0(subsets, subsetRows, combination);
    private static _Iterate_autogen1(supersetVariables, subsets, subsetRows, combination);
}
/**
*  Represents a Bayesian Network, or a Dynamic Bayesian Network.  To perform inference with a network see the {@link com.bayesserver.inference} namespace.
*
* A Bayesian network consists of nodes which contain one or more variables.  Each node can be connected with a directed {@link com.bayesserver.Link link} (A link in a Dynamic Bayesian Network can have an associated order which links nodes in different time slices).
* <p> Each node in a Bayesian network must have a distribution specified over its own variables conditional on its parents variables.  For example if a network contains nodes A and B each with a single variable of the same name, and A is a parent of B, then the distribution at A equals P(A), since A has no parents, and the distribution at B equals P(B|A).</p>

* <p>Once the nodes, links, and distributions in a Bayesian network have been specified, one or more inference engines can be created based on the network, to perform probabilistic inference.  See {@link com.bayesserver.inference.IInference}.</p>


* @see com.bayesserver.Node

* @see com.bayesserver.Link
*/
export declare class Network {
    private static _Beg_x_;
    private static readonly _Beh_x_;
    private _Bfa_x_;
    private _Bfb_x_;
    private _Bfc_x_;
    private _Bfd_x_;
    private _Bfe_x_;
    private _Bff_x_;
    private _Bfg_x_;
    private _Bfh_x_;
    private _Bga_x_;
    private _Bgb_x_;
    private _Bgc_x_;
    private _Bgd_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.Network} class.
*/
    constructor();
    /**
*  Initializes a new instance of the {@link com.bayesserver.Network} class with the specified [name].
*
* @param {string} name The optional name of the network.  Can be null.
*/
    constructor(name: string);
    private _cons_autogen0();
    private _cons_autogen1(name);
    /**
*  Gets custom properties associated with this instance.
*
*  Custom properties allow storage of custom information, which will be saved with the network.
*/
    readonly customProperties: CustomPropertyCollection;
    /**
*  Gets groups which nodes can belong to.
*
*  Each node can belong to one or more groups.
*/
    readonly nodeGroups: NetworkNodeGroupCollection;
    /**
*  Makes a copy of the network.

* @return {Network} The copy.
*/
    copy(): Network;
    /**
*  For internal use only.  May be removed in future versions.
*/
    /**
*  For internal use only.  May be removed in future versions.
*/
    isInternal: boolean;
    private _ssu_x_(p_autogen7);
    /**
*  Validates that the Bayesian network is correctly specified.
*
* @param {ValidationOptions} options Specifies options to control the validation process.

* @exception InvalidNetworkException Raised when the network is not correctly specified, containing the error message.
*/
    validate(options: ValidationOptions): void;
    /**
*  Determines whether this instance is a Directed Acyclic Graph (DAG) which is a requirement for Bayesian networks.

* @return {boolean} <code>true</code> if this instance is a DAG; otherwise, <code>false</code>.
*/
    isDag(): boolean;
    /**
*  Determines whether this instance is a tree (singly connected).

* @return {boolean} <code>true</code> if this instance is a tree; otherwise, <code>false</code>.
*/
    isTree(): boolean;
    /**
*  For internal use only.
*
* @param {INetworkMonitor} monitor

* @exception ReferenceError Raised if [monitor] is null.
*/
    addMonitor(monitor: INetworkMonitor): void;
    /**
*  For internal use.
*
* @param {INetworkMonitor} monitor

* @exception ReferenceError Raised if [monitor] is null.
*/
    removeMonitor(monitor: INetworkMonitor): void;
    _ssv_x_(p_autogen11: number, p_autogen12: Link, p_autogen13: Link, p_autogen14: CollectionAction, p_autogen15: boolean): void;
    private _stq_x_(p_autogen17);
    /**
*  The collection of nodes in the Bayesian network.

* @see com.bayesserver.Node
*/
    readonly nodes: NetworkNodeCollection;
    /**
*  The collection of variables in the Bayesian network.

* @see com.bayesserver.Variable
*/
    readonly variables: NetworkVariableCollection;
    /**
*  The collection of links in the Bayesian network.
*
*  Note that if a {@link com.bayesserver.Node} is removed from the network, all of its links are automatically removed.

* @see com.bayesserver.Link
*/
    readonly links: NetworkLinkCollection;
    /**
*  An optional name for the Bayesian network.
*/
    /**
*  An optional name for the Bayesian network.
*/
    name: string;
    /**
*  An optional description for the Bayesian network.
*/
    /**
*  An optional description for the Bayesian network.
*/
    description: string;
    /**
*  Saves the network to a string, with UTF-8 encoding.  For large networks consider saving to file or a stream.

* @return {string} The network persisted to a string.
*/
    saveToString(): string;
    /**
*  Loads a network from a string.
*
* @param {string} value The persisted string value of the network.
*/
    loadFromString(value: string): void;
    _str_x_(p_autogen19: Node, p_autogen20: NoisyType): void;
    _sts_x_(p_autogen22: Link, p_autogen23: NoisyOrder): void;
    _stt_x_(p_autogen25: number, p_autogen26: Node, p_autogen27: Node, p_autogen28: CollectionAction, p_autogen29: boolean): void;
    _stu_x_(p_autogen31: number, p_autogen32: Variable, p_autogen33: Variable, p_autogen34: CollectionAction, p_autogen35: boolean): void;
    _stv_x_(p_autogen37: StateCollection, p_autogen38: number, p_autogen39: State, p_autogen40: State, p_autogen41: CollectionAction, p_autogen42: boolean): void;
    _suq_x_(p_autogen44: Node, p_autogen45: NodeDistributionKey, p_autogen46: NodeDistributionKind, p_autogen47: IDistribution, p_autogen48: IDistribution): void;
    /**
*  When <code>true</code> synchronizes {@link com.bayesserver.Variable} names with their containing {@link com.bayesserver.Node}.
*
*  The synchronization is one way from the Node to the Variable only.
* <p>Synchronization only occurs when a node has a single variable, whose name matches its containing node.</p>

*/
    /**
*  When <code>true</code> synchronizes {@link com.bayesserver.Variable} names with their containing {@link com.bayesserver.Node}.
*
*  The synchronization is one way from the Node to the Variable only.
* <p>Synchronization only occurs when a node has a single variable, whose name matches its containing node.</p>

*/
    static syncNodeVariableName: boolean;
    private static _sst_x_(p_autogen0, p_autogen1, p_autogen2, p_autogen3, p_autogen4, p_autogen5);
}
/**
*  Represents the collection of directed links maintained by the {@link com.bayesserver.Network} class.  See {@link com.bayesserver.Network#getLinks} .  Duplicates and null values are not allowed.
*
* This collection contains all links in a network.  To find links specific to a particular node, see {@link com.bayesserver.Node#getLinksIn LinksIn} and {@link com.bayesserver.Node#getLinksOut LinksOut}.

* @see com.bayesserver.Node#getLinksIn

* @see com.bayesserver.Node#getLinksOut
*/
export declare class NetworkLinkCollection implements IList<Link> {
    private readonly _items;
    private readonly _Bge_x_;
    constructor(p_autogen0: Network);
    /**
* @inheritDoc
*/
    _2ad2e5f4b2884a52bf8bfc07ce8953d3(): void;
    /**
*  Gets the number of elements contained in the collection.

* @return {number}

* @return {number} The number of elements contained in the collection.
*/
    readonly size: number;
    /**
*  Gets a value indicating whether the collection read-only.  Always returns false;

* @return {boolean}

* @return {boolean} false
*/
    readonly isReadOnly: boolean;
    /**
*  Gets the {@link com.bayesserver.Network} the collection belongs to.
*/
    readonly network: Network;
    /**
*  Gets the {@link com.bayesserver.Link} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Link} to find.

* @return {Link} A {@link com.bayesserver.Link}.

* @exception ReferenceError Raised when value being set is null.

* @exception Error Raised if the value being set already belongs to a network, an equivalent link already exists, or the link nodes do not belong to the {@link com.bayesserver.Network}.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    get(index: number): Link;
    /**
*  Sets the {@link com.bayesserver.Link} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Link} to find.

* @exception ReferenceError Raised when value being set is null.

* @exception Error Raised if the value being set already belongs to a network, an equivalent link already exists, or the link nodes do not belong to the {@link com.bayesserver.Network}.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    set(index: number, value: Link): void;
    private _addInternal(item);
    /**
*  Removes all elements from the collection.
*/
    clear(): void;
    /**
*  Determines whether a {@link com.bayesserver.Link} is in the collection.  The operation is O(1).
*
* @param {Link} item The {@link com.bayesserver.Link} to locate in the collection. The value can be null.

* @return {boolean} true if [item] is found in the collection; otherwise, false.
*/
    includes(item: Link): boolean;
    /**
*  Finds a link from one node to another if it exists, otherwise returns null.
*
* @param {Node} from The from (parent) node.
*
* @param {Node} to The to (child) node.

* @return {Link} The link if found, otherwise null.
*/
    find(from: Node, to: Node): Link;
    /**
*  Finds a link from one node to another if it exists, otherwise returns null.
*
* @param {Node} from The from (parent) node.
*
* @param {Node} to The to (child) node.
*
* @param {number} temporalOrder The temporal order of the link.  Will be null unless the nodes are temporal nodes.

* @return {Link} The link if found, otherwise null.
*/
    find(from: Node, to: Node, temporalOrder: number): Link;
    private _Find_autogen0(from, to);
    private _Find_autogen1(from, to, temporalOrder);
    /**
*  Determines the index of a specific {@link com.bayesserver.Link} in the collection.  This operation is O(1).
*
* @param {Link} item The link. The value can be null.

* @return {number} The index of the link or -1 if not found.
*/
    indexOf(item: Link): number;
    /**
*  Inserts an element into the collection at the specified index.
*
* @param {number} index The zero based index at which to add the element.
*
* @param {Link} item The item to insert.  Cannot be null.

* @exception ReferenceError Raised if [item] is null.

* @exception Error Raised if the new link already belongs to a network, an equivalent link already exists, or the link nodes do not belong to the {@link com.bayesserver.Network}.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    insert(index: number, item: Link): void;
    /**
*  Removes the {@link com.bayesserver.Link} from the collection.
*
* @param {Link} item The {@link com.bayesserver.Link} to be removed from the collection.

* @return {boolean} true if item was successfully removed from the collection; otherwise, false. This method also returns false if item is not found in the collection.

* @exception ReferenceError Raised if [item] is null.
*/
    remove(item: Link): boolean;
    /**
*  Removes an element from the collection at the specified index.
*
* @param {number} index The zero based index at which to remove the element.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    removeAt(index: number): Link;
    private _sus_x_(p_autogen15);
    private _sut_x_(p_autogen16, p_autogen17, p_autogen18, p_autogen19);
    private _suu_x_(p_autogen20, p_autogen21, p_autogen22, p_autogen23);
    private _suv_x_(p_autogen24);
    private _svq_x_(p_autogen25);
    private static _sur_x_(p_autogen14);
    push(...items: Link[]): number;
    [Symbol.iterator](): Iterator<Link>;
}
/**
*  Represents the collection of {@link com.bayesserver.Network#getNodes} maintained by the {@link com.bayesserver.Network} class.  Duplicates and null values are not allowed.
*/
export declare class NetworkNodeCollection implements IList<Node> {
    private _Bgf_x_;
    private _items;
    private _Bgg_x_;
    constructor(p_autogen0: Network);
    /**
* @inheritDoc
*/
    _2ad2e5f4b2884a52bf8bfc07ce8953d3(): void;
    /**
*  Gets the {@link com.bayesserver.Node} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Node} to find.

* @return {Node} A {@link com.bayesserver.Node}.

* @exception ReferenceError Raised when value being set is null.

* @exception Error Raised if the value being set already belongs to a network.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    get(index: number): Node;
    /**
*  Performs a case sensitive lookup.
*
* @param {string} name The name of the {@link com.bayesserver.Node} to find.

* @return {Node} The {@link com.bayesserver.Node} with the specified name; otherwise null.
*/
    get(name: string): Node;
    /**
*  Performs a case sensitive lookup.
*
* @param {string} name The name of the {@link com.bayesserver.Node} to find.
*
* @param {boolean} throwIfNotFound When <code>true</code> throws an exception if the name is not found.

* @return {Node} The {@link com.bayesserver.Node} with the specified name; otherwise null.
*/
    get(name: string, throwIfNotFound: boolean): Node;
    private _get_autogen0(index);
    private _get_autogen1(name);
    private _get_autogen2(name, throwIfNotFound);
    /**
*  Sets the {@link com.bayesserver.Node} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Node} to find.

* @exception ReferenceError Raised when value being set is null.

* @exception Error Raised if the value being set already belongs to a network.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    set(index: number, value: Node): void;
    /**
*  The {@link com.bayesserver.Network} the collection belongs to.
*/
    readonly network: Network;
    /**
*  Determines whether a {@link com.bayesserver.Node} is in the collection.  The operation is O(1).
*
* @param {Node} node The {@link com.bayesserver.Node} to locate in the collection. The value can be null.

* @return {boolean} true if [node] is found in the collection; otherwise, false.
*/
    includes(node: Node): boolean;
    /**
*  Removes all elements from the collection.
*/
    clear(): void;
    private _svr_x_(p_autogen6, p_autogen7, p_autogen8, p_autogen9);
    private _svs_x_(p_autogen10, p_autogen11, p_autogen12, p_autogen13);
    /**
*  Adds the [nodes] to the end of the collection.
*
* @param {IList<Node>} nodes The collection whose elements should be added.  Cannot be null.

* @exception ReferenceError [nodes] collection is null.
*/
    pushList(nodes: IList<Node>): void;
    _svt_x_(p_autogen15: string): void;
    _svu_x_(p_autogen16: Node, p_autogen17: string, p_autogen18: string): void;
    /**
*  Inserts an element into the collection at the specified index.
*
* @param {number} index The zero based index at which to add the element.
*
* @param {Node} item The item to insert.  Cannot be null.

* @exception ReferenceError Raised when [item] is null.

* @exception Error Raised if the node already belongs to a network.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    insert(index: number, item: Node): void;
    private _svv_x_(p_autogen21);
    private _tqq_x_(p_autogen22);
    private _tqr_x_(p_autogen23);
    private _tqs_x_(p_autogen24);
    /**
*  Determines the index of a specific {@link com.bayesserver.Node} in the collection.  This operation is O(1).
*
* @param {Node} item The node.  The value can be null.

* @return {number} The index of the node or -1 if not found.
*/
    indexOf(item: Node): number;
    private _addInternal(item);
    /**
*  Removes the {@link com.bayesserver.Node} from the collection.
*
* @param {Node} item The {@link com.bayesserver.Node} to be removed from the collection.

* @return {boolean} true if item was successfully removed from the collection; otherwise, false. This method also returns false if item is not found in the collection.

* @exception ReferenceError Raised if [item] is null.
*/
    remove(item: Node): boolean;
    /**
*  Removes an element from the collection at the specified index, and any links that it has.
*
* @param {number} index The zero based index at which to remove the element.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    removeAt(index: number): Node;
    /**
*  Gets the number of elements contained in the collection.
*/
    readonly size: number;
    push(...items: Node[]): number;
    [Symbol.iterator](): Iterator<Node>;
}
/**
*  A collection of groups.
*/
export declare class NetworkNodeGroupCollection implements IList<NodeGroup> {
    private _Bgh_x_;
    private _items;
    private _Bha_x_;
    constructor(p_autogen0: Network);
    /**
* @inheritDoc
*/
    _2ad2e5f4b2884a52bf8bfc07ce8953d3(): void;
    /**
*  Gets the network instance that these groups belong to.
*/
    readonly network: Network;
    /**
*  Gets the {@link com.bayesserver.NodeGroup} with the specified name, from the collection, or returns null if not found.
*
* @param {string} name The name of the {@link com.bayesserver.NodeGroup} to return.

* @return {NodeGroup} The {@link com.bayesserver.NodeGroup} with the specified name, or null if not found.
*/
    get(name: string): NodeGroup;
    get(index: number): NodeGroup;
    private _get_autogen0(name);
    private _get_autogen1(index);
    /**
* @inheritDoc
*/
    clear(): void;
    [Symbol.iterator](): Iterator<NodeGroup>;
    /**
* @inheritDoc
*/
    removeAt(index: number): NodeGroup;
    private _tqt_x_(p_autogen3);
    /**
* @inheritDoc
*/
    insert(index: number, element: NodeGroup): void;
    _tqu_x_(p_autogen6: string): void;
    _tqv_x_(p_autogen7: NodeGroup, p_autogen8: string, p_autogen9: string): void;
    set(index: number, element: NodeGroup): NodeGroup;
    readonly size: number;
    includes(item: NodeGroup): boolean;
    push(...items: NodeGroup[]): number;
    indexOf(item: NodeGroup): number;
    remove(item: NodeGroup): boolean;
}
/**
*  Represents a read-only collection of variables that belong to a network.  When a variable is added to a {@link com.bayesserver.Node} it is automatically inserted into this collection.
*/
export declare class NetworkVariableCollection implements IList<Variable> {
    private _Bhc_x_;
    private _items;
    private _Bhd_x_;
    constructor(p_autogen0: Network);
    /**
* @inheritDoc
*/
    _2ad2e5f4b2884a52bf8bfc07ce8953d3(): void;
    /**
*  The {@link com.bayesserver.Network} the collection belongs to.
*/
    readonly network: Network;
    /**
*  Gets the number of elements contained in the {@link com.bayesserver.NetworkVariableCollection} instance.
*/
    readonly size: number;
    /**
*  Determines whether a {@link com.bayesserver.Variable} is in the collection.  The operation is O(1).
*
* @param {Variable} variable The {@link com.bayesserver.Variable} to locate in the collection. The value can be null.

* @return {boolean} true if [variable] is found in the collection; otherwise, false.
*/
    includes(variable: Variable): boolean;
    /**
*  Determines the index of a specific {@link com.bayesserver.Variable} in the collection.  This operation is O(1).
*
* @param {Variable} item The variable to find. The value can be null.

* @return {number} The index of the variable in the collection, or -1 if not found.
*/
    indexOf(item: Variable): number;
    private _tsr_x_(p_autogen3, p_autogen4, p_autogen5, p_autogen6);
    private _tss_x_(p_autogen7, p_autogen8, p_autogen9, p_autogen10);
    _tst_x_(p_autogen11: Variable): void;
    _tsu_x_(p_autogen12: string): void;
    _tsv_x_(p_autogen13: Variable, p_autogen14: string, p_autogen15: string): void;
    _ttq_x_(p_autogen16: Variable, p_autogen17: Node, p_autogen18: Variable): void;
    _ttr_x_(p_autogen19: Node): void;
    _tts_x_(p_autogen20: Node): void;
    /**
*  Performs a case sensitive lookup.
*
* @param {string} name The name of the {@link com.bayesserver.Variable} to find.

* @return {Variable} The {@link com.bayesserver.Variable} found with the specified name; otherwise null.
*/
    get(name: string): Variable;
    /**
*  Performs a case sensitive lookup.
*
* @param {string} name The name of the {@link com.bayesserver.Variable} to find.
*
* @param {boolean} throwIfNotFound When <code>true</code> throws an exception if the name is not found.

* @return {Variable} The {@link com.bayesserver.Variable} with the specified name; otherwise null.
*/
    get(name: string, throwIfNotFound: boolean): Variable;
    /**
*  Gets the {@link com.bayesserver.Variable} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Variable} to find.

* @return {Variable} A {@link com.bayesserver.Variable}.
*/
    get(index: number): Variable;
    private _get_autogen0(name);
    private _get_autogen1(name, throwIfNotFound);
    private _get_autogen2(index);
    /**
*  Gets the {@link com.bayesserver.Variable} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Variable} to find.

* @return {void} A {@link com.bayesserver.Variable}.
*/
    /**
*  Gets the {@link com.bayesserver.Variable} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Variable} to find.
*/
    set(index: number, value: Variable): void;
    push(...items: Variable[]): number;
    clear(): void;
    insert(index: number, item: Variable): void;
    remove(item: Variable): boolean;
    removeAt(index: number): Variable;
    [Symbol.iterator](): Iterator<Variable>;
}
/**
*  Represents a node with one or more variables in a Bayesian network.
*
*  Note that node names must be unique per network, and are case sensitive.
* <p> To specify a distribution for a node, see the {@link com.bayesserver.Node#getDistribution} property.</p>

* <p> To add a directed link between two nodes, it must be added through the {@link com.bayesserver.Network#getLinks Network.Links} property.</p>


* @see com.bayesserver.Network

* @see com.bayesserver.Link
*/
export declare class Node {
    private _Bhe_x_;
    private _Bhf_x_;
    private _Bhg_x_;
    private _Bhh_x_;
    private _Caa_x_;
    private _Cab_x_;
    private _Cac_x_;
    private _Cad_x_;
    private _Cae_x_;
    private _Caf_x_;
    private _Cag_x_;
    private _Cah_x_;
    private _Cba_x_;
    private _Cbb_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.Node} class, with no variables, and no name.
*/
    constructor();
    /**
*  Initializes a new instance of the {@link com.bayesserver.Node} class with a specified {@link com.bayesserver.Variable} and assigns the name of the variable to the node.
*
* @param {Variable} variable A single variable for the node.
*/
    constructor(variable: Variable);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Node} class with the specified [name]. A {@link com.bayesserver.Variable} is automatically created for the node and assigned the same name as the node with the {@link com.bayesserver.VariableValueType} specified.
*
* @param {string} name The name to give the node and variable, which can be null or empty.
*
* @param {VariableValueType} valueType The {@link com.bayesserver.VariableValueType} of the node variable, e.g. discrete or continuous.
*
* @param {VariableKind} kind The kind of variable, e.g. Probability (standard), Decision or Utility.
*/
    constructor(name: string, valueType: VariableValueType, kind: VariableKind);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Node} class with the specified [name].  A {@link com.bayesserver.Variable} is automatically created for the node and assigned the same name as the node with the {@link com.bayesserver.VariableValueType} specified.
*
* @param {string} name The name to give the node and variable, which can be null or empty.
*
* @param {VariableValueType} valueType The {@link com.bayesserver.VariableValueType} of the node variable, e.g. discrete or continuous.
*/
    constructor(name: string, valueType: VariableValueType);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Node} class with the specified [name] and automatically adds a discrete {@link com.bayesserver.Variable} with the number of states specified in [states].
*
* @param {string} name The name to give the node and variable, which can be null or empty.
*
* @param {number} states The number of states to add to the automatically created {@link com.bayesserver.Variable}.  States will be given default names.

* @exception RangeError Raised when the [states] parameter is less than zero.
*/
    constructor(name: string, states: number);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Node} class, with the name of the node, automatically creating an associated discrete {@link com.bayesserver.Variable} and adds the states specified in [states] to that variable.
*
* @param {string} name The name of the node and variable.
*
* @param {string[]} states The states to add to the associated {@link com.bayesserver.Variable}, specified by their names.

* @exception ReferenceError Raised when [states] is null.
*/
    constructor(name: string, states: string[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Node} class, with the name of the node, automatically creating an associated discrete {@link com.bayesserver.Variable} and adds the states specified in [states] to that variable.
*
* @param {string} name The name of the node and variable.
*
* @param {State[]} states The states to add to the associated {@link com.bayesserver.Variable}.

* @exception ReferenceError Raised when [states] is null.
*/
    constructor(name: string, states: State[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Node} class with a specified name and a number of variables.
*
* @param {string} name The name for the node.
*
* @param {Variable[]} variables The variable(s) represented by the node.
*/
    constructor(name: string, variables: Variable[]);
    private _cons_autogen0();
    private _cons_autogen1(variable);
    private _cons_autogen2(name, valueType, kind);
    private _cons_autogen3(name, valueType);
    private _cons_autogen4(name, states);
    private _cons_autogen5(name, states);
    private _cons_autogen6(name, states);
    private _cons_autogen7(name, variables);
    /**
*  Makes a copy of this instance.
*
*  The copy does not include links or distribution(s).

* @return {Node} The copy.
*/
    copy(): Node;
    /**
*  Gets custom properties associated with this instance.
*
*  Custom properties allow storage of custom information, which will be saved with the network.
*/
    readonly customProperties: CustomPropertyCollection;
    /**
*  Gets the groups this node belongs to.
*/
    readonly groups: NodeGroupCollection;
    /**
*  The {@link com.bayesserver.TemporalType} of the node.  The default value is {@link com.bayesserver.TemporalType#Contemporal}.

* @exception Error Raised if the node belongs to a network, in which case the TemporalType cannot be changed.
s    */
    /**
*  The {@link com.bayesserver.TemporalType} of the node.  The default value is {@link com.bayesserver.TemporalType#Contemporal}.

* @exception Error Raised if the node belongs to a network, in which case the TemporalType cannot be changed.
s    */
    temporalType: TemporalType;
    /**
*  Options that apply to all distributions of this instance.
*/
    readonly distributionOptions: NodeDistributionOptions;
    /**
*  Gets the size and location of the node.

* @return {Bounds} The size and location of the node.
*/
    /**
*  Sets the size and location of the node.
*
* @param {Bounds} value The size and location of the node.
*/
    bounds: Bounds;
    /**
*  Returns the name of the node, or an empty string if the name is null.

* @return {string}  A {@link String} containing the name of the node which is empty if the name is null.
*/
    toString(): string;
    private _ttt_x_(p_autogen14);
    _ttu_x_(p_autogen15: StateCollection, p_autogen16: number, p_autogen17: State, p_autogen18: State, p_autogen19: CollectionAction, p_autogen20: boolean): void;
    _ttv_x_(): void;
    /**
*  Creates a new distribution suitable for the requested temporal order, however it is not assigned to the node.  Use {@link com.bayesserver.Node#getDistributions} to perform the assignment.
*
*  See {@link com.bayesserver.NodeDistributions} for more information.
* <p>Note: if the resulting distribution contains continuous variables, but no discrete head variables, all table values are initialized to 1.</p>

*
* @param {number} temporalOrder The order for the requested distribution.

* @return {IDistribution} The new distribution.

* @see com.bayesserver.NodeDistributions
*/
    newDistribution(temporalOrder: number): IDistribution;
    /**
*  Creates a new distribution suitable for the requested temporal order/related node, however it is not assigned to the node.  Use {@link com.bayesserver.Node#getDistributions} to perform the assignment.
*
*  See {@link com.bayesserver.NodeDistributions} for more information.
* <p>Note: if the resulting distribution contains continuous variables, but no discrete head variables, all table values are initialized to 1.</p>

* <p> A noisy node is specified using multiple distributions, one for each parent and a leak distribution. Set the related node property to a parent, or set it to the current node to set the leak distribution.</p>

*
* @param {NodeDistributionKey} key Identifies the order/related node for the requested distribution.

* @return {IDistribution} The new distribution.

* @see com.bayesserver.NodeDistributions
*/
    newDistribution(key: NodeDistributionKey): IDistribution;
    /**
*  Creates a new distribution with the given kind, however it is not assigned to the node. Use {@link com.bayesserver.Node#getDistributions} to perform the assignment.  For temporal or noisy nodes us a different overload.
*
*  See {@link com.bayesserver.NodeDistributions} for more information.
* <p>Note: if the resulting distribution contains continuous variables, but no discrete head variables, all table values are initialized to 1.</p>

*
* @param {NodeDistributionKind} kind The kind of distribution to create.

* @return {IDistribution} The new distribution.

* @see com.bayesserver.NodeDistributions
*/
    newDistribution(kind: NodeDistributionKind): IDistribution;
    /**
*  Creates a new distribution suitable for the requested temporal order/related node, however it is not assigned to the node.  Use {@link com.bayesserver.Node#getDistributions} to perform the assignment.
*
*  See {@link com.bayesserver.NodeDistributions} for more information.
* <p>Note: if the resulting distribution contains continuous variables, but no discrete head variables, all table values are initialized to 1.</p>

* <p> Experience table entries are also initialized to 1.</p>

* <p> A noisy node is specified using multiple distributions, one for each parent and a leak distribution. Set the related node property to a parent, or set it to the current node to set the leak distribution.</p>

*
* @param {NodeDistributionKey} key Identifies the order/related node for the requested distribution.
*
* @param {NodeDistributionKind} kind The kind of distribution to create.

* @return {IDistribution} The new distribution.

* @see com.bayesserver.NodeDistributions
*/
    newDistribution(key: NodeDistributionKey, kind: NodeDistributionKind): IDistribution;
    /**
*  Creates a new distribution suitable for the node, however does not assign it to the node's {@link com.bayesserver.Node#getDistribution} property.
*
*  This method is useful for creating distributions appropriate for a node.  However, the returned distribution cannot be set to {@link com.bayesserver.Node#getDistribution} until the distribution has been correctly specified.
* <p>Note: if the resulting distribution contains continuous variables, but no discrete head variables, all table values are initialized to 1.</p>


* @return {IDistribution} A new distribution.

* @exception Error Raised if the node or one of it's parents has zero states.
*/
    newDistribution(): IDistribution;
    private _NewDistribution_autogen0(temporalOrder);
    private _NewDistribution_autogen1(key);
    private _NewDistribution_autogen2(kind);
    private _NewDistribution_autogen3(key, kind);
    private _NewDistribution_autogen4();
    _tuq_x_(p_autogen28: NodeDistributionKey, p_autogen29: NodeDistributionKind, p_autogen30: (arg0: IList<VariableContext>) => Table, p_autogen31: (arg0: IList<VariableContext>) => CLGaussian): IDistribution;
    /**
*  Returns the distribution currently associated with the {@link com.bayesserver.Node}.  The distribution cannot be modified when it is assigned to a node.  It is also automatically set to null, when certain structural changes occur (see remarks).
*
*  If a structural change occurs to the network that invalidates the current distribution, it is automatically set to null. This occurs in the following situations:<list><item>States are added or removed from the node.</item><item>States are added or removed from one of the node's parents.</item><item>The {@link com.bayesserver.Node#getLinksIn} collection changes.  I.e. adding or removing a parent node.  Note that if a node is removed from a network, all of its links are automatically removed also.</item></list>

* @exception Error Raised when the distribution is invalid.
*/
    /**
*  Returns the distribution currently associated with the {@link com.bayesserver.Node}.  The distribution cannot be modified when it is assigned to a node.  It is also automatically set to null, when certain structural changes occur (see remarks).
*
*  If a structural change occurs to the network that invalidates the current distribution, it is automatically set to null. This occurs in the following situations:<list><item>States are added or removed from the node.</item><item>States are added or removed from one of the node's parents.</item><item>The {@link com.bayesserver.Node#getLinksIn} collection changes.  I.e. adding or removing a parent node.  Note that if a node is removed from a network, all of its links are automatically removed also.</item></list>

* @exception Error Raised when the distribution is invalid.
*/
    distribution: IDistribution;
    /**
*  Returns the distributions associated with this instance with NodeDistributionKind = Probability.  Some node types such as temporal nodes can have more than one distribution assigned to them.
*/
    readonly distributions: NodeDistributions;
    /**
*  The name of the node.  Node names in a network must be unique, and comparisons are case sensitive.
*/
    /**
*  The name of the node.  Node names in a network must be unique, and comparisons are case sensitive.
*/
    name: string;
    /**
*  An optional description for the node.
*/
    /**
*  An optional description for the node.
*/
    description: string;
    /**
*  The {@link com.bayesserver.Network} the node belongs to. Value will be null unless the node has been added to a network.
*/
    readonly network: Network;
    _setNetwork(value: Network): void;
    /**
*  Collection of both incoming and outgoing links (parent and child nodes).
*/
    readonly links: NodeLinkCollection;
    /**
*  Collection of variables represented by the node.
*/
    readonly variables: NodeVariableCollection;
    /**
*  Collection of incoming links (linking to parent nodes).
*/
    readonly linksIn: NodeLinkCollection;
    /**
*  Collection of outgoing links (linking to child nodes).
*/
    readonly linksOut: NodeLinkCollection;
    /**
*  The Index of this instance in the collection of nodes belonging to a network, or -1 if the node does not belong to a network.
*/
    readonly index: number;
    _setIndex(value: number): void;
}
/**
*  Identifies a distribution assigned or to be assigned to a node.
*
*  Some nodes may have more than one distribution assigned to them (e.g. temporal nodes or noisy nodes), and this is used to differentiate between them.
*/
export declare class NodeDistributionKey {
    private _Cbc_x_;
    private _Cbd_x_;
    private static _Cbe_x_;
    /**
*  Initializes a new instance of the NodeDistributionKey class with defaults.
*/
    constructor();
    /**
*  Initializes a new instance of a NodeDistributionKey.
*
* @param {number} order The temporal order of the node distribution.
*/
    constructor(order: number);
    /**
*  Initializes a new instance of a {@link com.bayesserver.NodeDistributionKey}.
*
* @param {Node} relatedNode The parent of the noisy node this distribution refers to, or the noisy node itself to identify the leak distribution.  This will be null, unless the node is a noisy node.
*/
    constructor(relatedNode: Node);
    /**
*  Initializes a new instance of a {@link com.bayesserver.NodeDistributionKey}.
*
* @param {number} order The temporal order of the related node distribution.
*
* @param {Node} relatedNode The parent of the noisy node this distribution refers to, or the noisy node itself to identify the leak distribution.  This will be null, unless the node is a noisy node.
*/
    constructor(order: number, relatedNode: Node);
    private _cons_autogen0();
    private _cons_autogen1(order);
    private _cons_autogen2(relatedNode);
    private _cons_autogen3(order, relatedNode);
    /**
*  Gets the temporal order of the related node distribution.
*/
    readonly order: number;
    /**
*  Gets the parent of the noisy node this distribution refers to, or the noisy node itself to identify the leak distribution.  This will be null, unless the node is a noisy node.
*
*  A noisy node is specified using multiple distributions, one for each parent and a leak distribution. Set the related node property to a parent, or set it to the current node to set the leak distribution.
*/
    readonly relatedNode: Node;
    /**
*  Indicates whether the current object is equal to another object of the same type.
*
* @param {NodeDistributionKey} other An object to compare with this object.

* @return {boolean}  true if the current object is equal to the [other] parameter; otherwise, false.
*/
    equals(other: NodeDistributionKey): boolean;
    /**
* @inheritDoc
*/
    compareTo(other: NodeDistributionKey): number;
    /**
*  Gets a default instance, which is equivalent to constructing a new instance with the default constructor.
*/
    static readonly default: NodeDistributionKey;
    private static _compareTo<T>(a, b);
}
/**
*  The kind of distribution, such as a standard Probability or Experience table.
*/
export declare class NodeDistributionKind {
    /**
*  The standard kind of probability distribution found in Bayesian networks.
*/
    static readonly Probability: NodeDistributionKind;
    /**
*  A distribution which contains experience for the node, used in online learning.
*
*
* <p> Once an experience table is combined with the probability of a discrete node, this creates a a Dirichlet distribution which can be used in online learning.</p>

*/
    static readonly Experience: NodeDistributionKind;
    /**
*  A table which contains fading values used in online learning.  A value of 1 in the table represents no fading.
*
*  Fading can be used to decrease the importance of previous experience.
*/
    static readonly Fading: NodeDistributionKind;
}
/**
*  Options that apply to all distributions of a particular node.
*/
export declare class NodeDistributionOptions {
    private _Cbf_x_;
    private _Cbg_x_;
    private _Cbh_x_;
    constructor(p_autogen0: Node);
    /**
*  The node this instance belongs to.
*/
    readonly node: Node;
    _setNode(value: Node): void;
    /**
*  Copies this instance.

* @return {NodeDistributionOptions} The copy.
*/
    copy(): NodeDistributionOptions;
    /**
*  Gets a value which identifies this node as a noisy node or not.
*/
    /**
*  Sets a value which identifies this node as a noisy node or not.
*/
    noisyType: NoisyType;
    /**
*  Determines whether {@link com.bayesserver.CLGaussian} intercept terms are fixed to zero.
*
*  This only applies to {@link com.bayesserver.CLGaussian} distributions with tails.
* <p> When <code>true</code>, the parameter count of the network reduces accordingly.</p>

*/
    /**
*  Determines whether {@link com.bayesserver.CLGaussian} intercept terms are fixed to zero.
*
*  This only applies to {@link com.bayesserver.CLGaussian} distributions with tails.
* <p> When <code>true</code>, the parameter count of the network reduces accordingly.</p>

*/
    hasZeroIntercepts: boolean;
}
/**
*  Represents the distributions assigned to a {@link com.bayesserver.Node}. Temporal nodes may require more than one distribution to be fully specified.
*
*  In a Dynamic Bayesian Network (DBN) a node may require more than one distribution to be specified. This occurs when a temporal node has incoming links of order greater than zero.  I.e. Has links from past time slices. For example, if a temporal node has an incoming link of order 1, then it will require a distribution at time t=0, and an additional distribution at t=1.  This is because at time t=0 there is no previous  time slice, but at time t=1 there is.  For times greater than 1, in this example the distribution  specified at time t=1 is still valid.  However, if a new incoming link of order 12 was added, then an additional distribution would need to be specified at time t=12, valid for times t>=12.
*/
export declare class NodeDistributions implements Map<NodeDistributionKey, IDistribution> {
    private _Cca_x_;
    private _Ccb_x_;
    constructor(p_autogen0: Node);
    private _tur_x_();
    /**
*  Finds the temporal distribution that is suitable for the time specified.
*
* @param {number} time The time.

* @return {DistributionOrder} The distribution and order that is appropriate for the given time.  Can return a null distribution, if the appropriate distribution has not yet been assigned to the node.

* @exception Error Raised when an appropriate distribution could not be found.
*/
    findForTimeWithOrder(time: number): DistributionOrder;
    /**
*  Finds the temporal distribution that is suitable for the time specified.
*
* @param {number} time The time.
*
* @param {NodeDistributionKind} kind The kind of distribution to retrieve.

* @return {DistributionOrder} The distribution that is appropriate for the given time.  Can return a null distribution, if the appropriate distribution has not yet been assigned to the node.

* @exception Error Raised when an appropriate distribution could not be found.
*/
    findForTimeWithOrder(time: number, kind: NodeDistributionKind): DistributionOrder;
    private _FindForTimeWithOrder_autogen0(time);
    private _FindForTimeWithOrder_autogen1(time, kind);
    /**
*  Finds the temporal distribution that is suitable for the time specified.
*
* @param {number} time The time.
*
* @param {NodeDistributionKind} kind The kind of distribution to retrieve.

* @return {IDistribution} The distribution and order that is appropriate for the given time.  Can return a null distribution, if the appropriate distribution has not yet been assigned to the node.

* @exception Error Raised when an appropriate distribution could not be found.
*/
    findForTime(time: number, kind: NodeDistributionKind): IDistribution;
    /**
*  Finds the temporal distribution that is suitable for the time specified.
*
* @param {number} time The time.

* @return {IDistribution} The distribution that is appropriate for the given time.  Can return a null distribution, if the appropriate distribution has not yet been assigned to the node.

* @exception Error Raised when an appropriate distribution could not be found.
*/
    findForTime(time: number): IDistribution;
    private _FindForTime_autogen0(time, kind);
    private _FindForTime_autogen1(time);
    /**
*  Gets the node that this instance belongs to.
*/
    readonly node: Node;
    _tus_x_(): void;
    _tut_x_(p_autogen7: number): void;
    _containsKey(p_autogen8: NodeDistributionKey): boolean;
    private _tuu_x_(p_autogen9);
    _tuv_x_(): void;
    private _tvq_x_(p_autogen10, p_autogen11);
    _tvr_x_(p_autogen12: Link): void;
    _tvs_x_(p_autogen13: Link): void;
    _tvt_x_(p_autogen14: number): void;
    /**
*  Gets the current maximum temporal order.
*/
    readonly maxTemporalOrder: number;
    /**
*  Determines whether the distribution at the specified temporal order can be updated.
*
* @param {NodeDistributionKey} key Properties identifying the distribution to check, such as temporal order/related node.

* @return {boolean} <code>true</code> if the distribution can be updated, <code>false</code> otherwise.
*/
    canUpdate(key: NodeDistributionKey): boolean;
    /**
*  Determines whether the distribution at the specified temporal order can be updated.
*
* @param {NodeDistributionKey} key Properties identifying the distribution to check, such as temporal order/related node.
*
* @param {NodeDistributionKind} kind The kind of distribution to check.

* @return {boolean} <code>true</code> if the distribution can be updated, <code>false</code> otherwise.
*/
    canUpdate(key: NodeDistributionKey, kind: NodeDistributionKind): boolean;
    private _CanUpdate_autogen0(key);
    private _CanUpdate_autogen1(key, kind);
    /**
*  Checks that a distribution is correctly specified for a particular temporal order.
*
* @param {IDistribution} value The distribution to test.
*
* @param {NodeDistributionKey} key The properties that identify a particular distribution such as temporal order/related node.
*/
    validateDistribution(value: IDistribution, key: NodeDistributionKey): void;
    /**
*  Checks that a distribution is correctly specified for a particular temporal order.
*
* @param {IDistribution} value The distribution to test.
*
* @param {NodeDistributionKey} key The properties that identify a particular distribution such as temporal order/related node.
*
* @param {NodeDistributionKind} kind The kind of distribution to validate.
*/
    validateDistribution(value: IDistribution, key: NodeDistributionKey, kind: NodeDistributionKind): void;
    private _ValidateDistribution_autogen0(value, key);
    private _ValidateDistribution_autogen1(value, key, kind);
    private _uqr_x_(p_autogen33);
    private _uqs_x_(p_autogen34, p_autogen35, p_autogen36);
    /**
*  Gets a distribution at a particular temporal order.
*
*  When specifying temporal distributions, variables which belong to temporal nodes must have times associated. Each time must be specified relative to the current point in time which is defined as zero.  E.g. to specify a distribution at time>=1 we would include variables at time -1 and 0.
*
* @param {number} temporalOrder The required temporal order.

* @return {IDistribution} The requested distribution, which can be null if the node does not support the requested temporal order, or if a distribution has not yet been assigned to that order.

* @exception RangeError [temporalOrder] must be non negative.
*/
    get(temporalOrder: number): IDistribution;
    /**
*  Gets a distribution with particular properties, such as temporal order.
*
*
* <p> When specifying temporal distributions, variables which belong to temporal nodes must have times associated. Each time must be specified relative to the current point in time which is defined as zero.  E.g. to specify a distribution at time>=1 we would include variables at time -1 and 0.</p>

* <p> For noisy nodes, multiple distributions are required, one for each parent and a leak distribution. </p>

*
* @param {NodeDistributionKey} key The properties of the required distribution, such as temporal order.

* @return {IDistribution} The requested distribution, which can be null if the node does not support the requested temporal order, or if a distribution has not yet been assigned to that order.

* @exception RangeError Temporal order must be non negative.
*/
    get(key: NodeDistributionKey): IDistribution;
    /**
*  Gets a particular kind of distribution on the node.
*
*
* <p> For temporal or noisy nodes, use the overload which accepts both a key and kind.</p>

*/
    get(kind: NodeDistributionKind): IDistribution;
    /**
*  Gets a distribution with particular properties, such as temporal order.
*
*
* <p> When specifying temporal distributions, variables which belong to temporal nodes must have times associated. Each time must be specified relative to the current point in time which is defined as zero.  E.g. to specify a distribution at time>=1 we would include variables at time -1 and 0.</p>

* <p> For noisy nodes, multiple distributions are required, one for each parent and a leak distribution. </p>

*
* @param {NodeDistributionKey} key The properties of the required distribution, such as temporal order.
*
* @param {NodeDistributionKind} kind The kind of distribution we are getting or setting.  This allows setting other distribution types than Probability, such as Experience

* @return {IDistribution} The requested distribution, which can be null if the node does not support the requested temporal order, or if a distribution has not yet been assigned to that order.

* @exception RangeError Temporal order must be non negative.
*/
    get(key: NodeDistributionKey, kind: NodeDistributionKind): IDistribution;
    private _get_autogen0(temporalOrder);
    private _get_autogen1(key);
    private _get_autogen2(kind);
    private _get_autogen3(key, kind);
    /**
*  Sets a distribution at a particular temporal order.
*
*  When specifying temporal distributions, variables which belong to temporal nodes must have times associated. Each time must be specified relative to the current point in time which is defined as zero.  E.g. to specify a distribution at time>=1 we would include variables at time -1 and 0.
*
* @param {number} temporalOrder The required temporal order.

* @exception RangeError [temporalOrder] must be non negative.
*/
    set(temporalOrder: number, value: IDistribution): this;
    /**
*  Sets a distribution with particular properties, such as temporal order.
*
*
* <p> When specifying temporal distributions, variables which belong to temporal nodes must have times associated. Each time must be specified relative to the current point in time which is defined as zero.  E.g. to specify a distribution at time>=1 we would include variables at time -1 and 0.</p>

* <p> For noisy nodes, multiple distributions are required, one for each parent and a leak distribution. </p>

*
* @param {NodeDistributionKey} key The properties of the required distribution, such as temporal order.

* @exception RangeError Temporal order must be non negative.
*/
    set(key: NodeDistributionKey, value: IDistribution): this;
    /**
*  Sets a particular kind of distribution on the node.
*
*
* <p> For temporal or noisy nodes, use the overload which accepts both a key and kind.</p>

*/
    set(kind: NodeDistributionKind, value: IDistribution): this;
    /**
*  Sets a distribution with particular properties, such as temporal order.
*
*
* <p> When specifying temporal distributions, variables which belong to temporal nodes must have times associated. Each time must be specified relative to the current point in time which is defined as zero.  E.g. to specify a distribution at time>=1 we would include variables at time -1 and 0.</p>

* <p> For noisy nodes, multiple distributions are required, one for each parent and a leak distribution. </p>

*
* @param {NodeDistributionKey} key The properties of the required distribution, such as temporal order.
*
* @param {NodeDistributionKind} kind The kind of distribution we are getting or setting.  This allows setting other distribution types than Probability, such as Experience

* @exception RangeError Temporal order must be non negative.
*/
    set(key: NodeDistributionKey, kind: NodeDistributionKind, value: IDistribution): this;
    private _set_autogen0(temporalOrder, value);
    private _set_autogen1(key, value);
    private _set_autogen2(kind, value);
    private _set_autogen3(key, kind, value);
    /**
*  Gets the number of distributions in the container.
*/
    readonly size: number;
    private static _tvu_x_(p_autogen23, p_autogen24, p_autogen25, p_autogen26, p_autogen27);
    private static _tvv_x_(p_autogen28, p_autogen29, p_autogen30, p_autogen31);
    private static _uqq_x_(p_autogen32);
    private static _uqt_x_(p_autogen37);
    clear(): void;
    delete(key: NodeDistributionKey): boolean;
    has(key: NodeDistributionKey): boolean;
    keys(): IterableIterator<NodeDistributionKey>;
    values(): IterableIterator<IDistribution>;
    forEach(callbackfn: (value: IDistribution, key: NodeDistributionKey, map: Map<NodeDistributionKey, IDistribution>) => void, thisArg?: any): void;
    [Symbol.iterator](): IterableIterator<[NodeDistributionKey, IDistribution]>;
    entries(): IterableIterator<[NodeDistributionKey, IDistribution]>;
    [Symbol.toStringTag]: "Map";
    private _sortedLookup;
}
/**
*  Allows nodes to be assigned to one or more groups.
*/
export declare class NodeGroup {
    private _Ccc_x_;
    private _Ccd_x_;
    private _Cce_x_;
    private _Ccf_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.NodeGroup} class.
*
* @param {string} name The name of the group, which must be unique per {@link com.bayesserver.NodeGroup}.
*/
    constructor(name: string);
    private _uqu_x_(p_autogen1);
    /**
*  Gets custom properties associated with this instance.
*
*  Custom properties allow storage of custom information, which will be saved with the network.
*/
    readonly customProperties: CustomPropertyCollection;
    /**
*  Makes a copy of this instance.

* @return {NodeGroup} The copy.
*/
    copy(): NodeGroup;
    /**
*  Gets the name, which must be unique per {@link com.bayesserver.NetworkNodeGroupCollection}.
*/
    /**
*  Gets the name, which must be unique per {@link com.bayesserver.NetworkNodeGroupCollection}.
*/
    name: string;
    /**
*  An optional description for the custom property.
*/
    /**
*  An optional description for the custom property.
*/
    description: string;
    /**
*  Gets the parent collection, if set, otherwise null.
*/
    readonly parent: NetworkNodeGroupCollection;
    _setParent(value: NetworkNodeGroupCollection): void;
}
/**
*  Represents the collection of groups a node belongs to.
*/
export declare class NodeGroupCollection implements IList<string> {
    private _Ccg_x_;
    private _items;
    constructor(p_autogen0: Node, p_autogen1: IList<string>);
    /**
* @inheritDoc
*/
    _2ad2e5f4b2884a52bf8bfc07ce8953d3(): void;
    [Symbol.iterator](): Iterator<string>;
    /**
*  The {@link com.bayesserver.Node} the collection belongs to.
*/
    readonly node: Node;
    /**
*  Gets the number of elements contained in the {@link com.bayesserver.NodeGroupCollection} instance.
*/
    readonly size: number;
    /**
*  Determines the index of a specific group in the collection.
*
* @param {string} item The node group name to find.  The value can be null.

* @return {number} The index of the group name in the collection, or -1 if not found.
*/
    indexOf(item: string): number;
    _uqv_x_(p_autogen3: NodeGroup, p_autogen4: string, p_autogen5: string): void;
    /**
*  Determines whether a group name is in the collection.
*
* @param {string} group The group to locate in the collection. The value can be null.

* @return {boolean} true if [group] is found in the collection; otherwise, false.
*/
    includes(group: string): boolean;
    /**
*  Inserts an element into the collection at the specified index.
*
* @param {number} index The zero based index at which to add the element.
*
* @param {string} item The item to insert.  Cannot be null.

* @exception ReferenceError Raised if [item] is null.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    insert(index: number, item: string): void;
    private _addInternal(item);
    /**
*  Removes all elements from the collection.
*/
    clear(): void;
    /**
*  Removes the group from the collection.
*
* @param {string} item The group to be removed from the collection.

* @return {boolean} true if item was successfully removed from the collection; otherwise, false. This method also returns false if item is not found in the collection.

* @exception ReferenceError Raised if [item] is null.
*/
    remove(item: string): boolean;
    /**
*  Removes an element from the collection at the specified index.
*
* @param {number} index The zero based index at which to remove the element.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    removeAt(index: number): string;
    /**
*  Gets the group at the specified index.
*
* @param {number} index The zero-based index of the group to find.

* @return {string} A group name.
*/
    get(index: number): string;
    /**
*  Sets the group at the specified index.
*
* @param {number} index The zero-based index of the group to find.
*/
    set(index: number, value: string): void;
    push(...items: string[]): number;
}
/**
*  Represents a read-only collection of links.  To add a link to a network see {@link com.bayesserver.Network#getLinks Links}.
*
* {@link com.bayesserver.Node#getLinks}, {@link com.bayesserver.Node#getLinksIn} and {@link com.bayesserver.Node#getLinksOut} are instances of this class.
*/
export declare class NodeLinkCollection implements IList<Link> {
    private _items;
    private _Cch_x_;
    constructor(p_autogen0: Node, p_autogen1: IList<Link>);
    /**
* @inheritDoc
*/
    _2ad2e5f4b2884a52bf8bfc07ce8953d3(): void;
    [Symbol.iterator](): Iterator<Link>;
    /**
*  Searches for the specified object and returns the zero-based index of the {@link com.bayesserver.Link} within the entire collection, or -1 if not found.
*
* @param {Link} item The {@link com.bayesserver.Link} to locate in the collection. The value can be null.

* @return {number} The zero-based index of the {@link com.bayesserver.Link} within the entire collection, if found; otherwise, �1.
*/
    indexOf(item: Link): number;
    /**
*  Determines whether a {@link com.bayesserver.Link} is in the collection.
*
* @param {Link} item The {@link com.bayesserver.Link} to locate in the collection. The value can be null.

* @return {boolean} true if item is found in the collection; otherwise, false.
*/
    includes(item: Link): boolean;
    /**
*  Gets the {@link com.bayesserver.Node} to which the collection belongs to.

* @return {Node} The {@link com.bayesserver.Node} that the collection belongs to.
*/
    readonly node: Node;
    _urq_x_(p_autogen4: Link): void;
    _urr_x_(p_autogen5: Link): void;
    /**
*  Gets the {@link com.bayesserver.Link} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Link} to find.

* @return {Link} A {@link com.bayesserver.Link}.
*/
    get(index: number): Link;
    /**
*  Gets the {@link com.bayesserver.Link} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Link} to find.

* @return {void} A {@link com.bayesserver.Link}.
*/
    /**
*  Gets the {@link com.bayesserver.Link} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Link} to find.
*/
    set(index: number, value: Link): void;
    /**
*  Gets the number of elements contained in the collection.
*/
    readonly size: number;
    push(...items: Link[]): number;
    clear(): void;
    insert(index: number, item: Link): void;
    remove(item: Link): boolean;
    removeAt(index: number): Link;
}
/**
*  Identifies a node and related time.
*/
export declare class NodeTime {
    private _Cda_x_;
    private _Cdb_x_;
    constructor();
    constructor(p_autogen0: Node, p_autogen1: number | null);
    private _cons_autogen0();
    private _cons_autogen1(p_autogen0, p_autogen1);
    /**
*  Gets the node.
*/
    readonly node: Node;
    _setNode(value: Node): void;
    /**
*  Gets the time of the node, or null if a time is not appropriate for the temporal type of the node.
*/
    readonly time: number | null;
    _setTime(value: number | null): void;
}
/**
*  Represents the collection of variables belonging to a
* @see com.bayesserver.Node
.
*/
export declare class NodeVariableCollection implements IList<Variable> {
    private static readonly _Cdc_x_;
    private _Cdd_x_;
    private _Cde_x_;
    private _items;
    constructor(p_autogen0: Node, p_autogen1: IList<Variable>);
    /**
* @inheritDoc
*/
    _2ad2e5f4b2884a52bf8bfc07ce8953d3(): void;
    [Symbol.iterator](): Iterator<Variable>;
    /**
*  The {@link com.bayesserver.Node} the collection belongs to.
*/
    readonly node: Node;
    /**
*  Gets the number of elements contained in the {@link com.bayesserver.NodeVariableCollection} instance.
*/
    readonly size: number;
    /**
*  Determines the index of a specific {@link com.bayesserver.Variable} in the collection.
*
* @param {Variable} item The variable to find.  The value can be null.

* @return {number} The index of the variable in the collection, or -1 if not found.
*/
    indexOf(item: Variable): number;
    /**
*  Determines whether a {@link com.bayesserver.Variable} is in the collection.
*
* @param {Variable} variable The {@link com.bayesserver.Variable} to locate in the collection. The value can be null.

* @return {boolean} true if [variable] is found in the collection; otherwise, false.
*/
    includes(variable: Variable): boolean;
    /**
*  Inserts an element into the collection at the specified index.
*
* @param {number} index The zero based index at which to add the element.
*
* @param {Variable} item The item to insert.  Cannot be null.

* @exception ReferenceError Raised if [item] is null.

* @exception Error Raised if the new variable already belongs to a node.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    insert(index: number, item: Variable): void;
    private _addInternal(item);
    /**
*  Removes all elements from the collection.
*/
    clear(): void;
    /**
*  Removes the {@link com.bayesserver.Variable} from the collection.
*
* @param {Variable} item The {@link com.bayesserver.Variable} to be removed from the collection.

* @return {boolean} true if item was successfully removed from the collection; otherwise, false. This method also returns false if item is not found in the collection.

* @exception ReferenceError Raised if [item] is null.
*/
    remove(item: Variable): boolean;
    /**
*  Removes an element from the collection at the specified index.
*
* @param {number} index The zero based index at which to remove the element.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    removeAt(index: number): Variable;
    _urs_x_(p_autogen9: string): void;
    _urt_x_(p_autogen10: Variable, p_autogen11: string, p_autogen12: string): void;
    /**
*  Gets the {@link com.bayesserver.Variable} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Variable} to find.

* @return {Variable} A {@link com.bayesserver.Variable}.
*/
    get(index: number): Variable;
    /**
*  Performs a case sensitive lookup.
*
* @param {string} name The name of the {@link com.bayesserver.Variable} to find.

* @return {Variable} The {@link com.bayesserver.Variable} with the specified name; otherwise null.
*/
    get(name: string): Variable;
    private _get_autogen0(index);
    private _get_autogen1(name);
    /**
*  Sets the {@link com.bayesserver.Variable} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Variable} to find.
*/
    set(index: number, value: Variable): void;
    push(...items: Variable[]): number;
}
/**
*  Determines the order in which the states of a parent of a noisy node increasingly affect the noisy states.
*/
export declare class NoisyOrder {
    /**
*  The states of the parent affect the noisy node states in increasing order.
*
*
* <p> In this mode, the first state of the parent variable has no effect, then each subsequent state has increasing causal influence of the noisy node states.</p>

*/
    static readonly Ascending: NoisyOrder;
    /**
*  The states of the parent affect the noisy node states in decreasing order.
*
*
* <p> In this mode, the last state of the parent variable has no effect, and previous states have increasing causal influence over the noisy node states.</p>

*/
    static readonly Descending: NoisyOrder;
}
/**
*  Identifies the noisy node type, if any.

* @see com.bayesserver.NodeDistributionOptions
*/
export declare class NoisyType {
    /**
*  The node is not a noisy node.
*/
    static readonly None: NoisyType;
    /**
*  The node is a noisy or/max node.
*/
    static readonly NoisyOrMax: NoisyType;
}
/**
*  Raised when the arguments to a mathematic function are not in the domain of the function (undefined).
*/
export declare class NotInDomainError extends Error {
    /**
    *  Initializes a new instance of the {@link NotInDomainError} class.
    */
    constructor();
    /**
    *  Initializes a new instance of the {@link NotInDomainError} class with a specified error message.
    *
    * @param message The error message that explains the reason for the exception.
    */
    constructor(message: string);
}
/**
*  Raised when a matrix is not positive definite.
*/
export declare class NotSpdError extends Error {
    /**
    *  Initializes a new instance of the {@link NotSpdError} class.
    */
    constructor();
    /**
    *  Initializes a new instance of the {@link NotSpdError} class with a specified error message.
    *
    * @param message The error message that explains the reason for the exception.
    */
    constructor(message: string);
}
/**
*  Contains methods to determine the number of parameters in a Bayesian network or distribution.
*/
export declare class ParameterCounter {
    /**
*  Gets the number of parameters in a Bayesian network.
*
* @param {Network} network The network.

* @return {number} The number of parameters.

* @exception ReferenceError Thrown if [network] is null.
*/
    static getParameterCount(network: Network): number;
    /**
*  Gets the number of parameters in a Bayesian network.
*
* @param {Network} network The network.
*
* @param {ParameterCountOptions} options Options governing the parameter count.

* @return {number} The number of parameters.

* @exception ReferenceError Thrown if [network] is null.
*/
    static getParameterCount(network: Network, options: ParameterCountOptions): number;
    /**
*  Gets the parameter count for an individual node distribution.
*
* @param {Node} node The node that owns the distribution.
*
* @param {number} order The distribution order.  Always zero for non temporal nodes.

* @return {number} The parameter count.
*/
    static getParameterCount(node: Node, order: number): number;
    /**
*  Gets the parameter count for an individual node distribution.
*
* @param {Node} node The node that owns the distribution.
*
* @param {NodeDistributionKey} key The distribution key.  Order is always zero for non temporal nodes.

* @return {number} The parameter count.
*/
    static getParameterCount(node: Node, key: NodeDistributionKey): number;
    private static _GetParameterCount_autogen0(network);
    private static _GetParameterCount_autogen1(network, options);
    private static _GetParameterCount_autogen2(node, order);
    private static _GetParameterCount_autogen3(node, key);
    /**
*  Gets the number of parameters in a Bayesian network.
*
* @param {Network} network The network.

* @return {number} The number of parameters.

* @exception ReferenceError Thrown if [network] is null.
*/
    static getParameterCountLong(network: Network): number;
    /**
*  Gets the number of parameters in a Bayesian network.
*
* @param {Network} network The network.
*
* @param {ParameterCountOptions} options Options governing the parameter count.

* @return {number} The number of parameters.

* @exception ReferenceError Thrown if [network] is null.
*/
    static getParameterCountLong(network: Network, options: ParameterCountOptions): number;
    /**
*  Gets the parameter count for an individual node distribution.
*
* @param {Node} node The node that owns the distribution.
*
* @param {NodeDistributionKey} key The distribution key.  Order is always zero for non temporal nodes.

* @return {number} The parameter count.
*/
    static getParameterCountLong(node: Node, key: NodeDistributionKey): number;
    private static _GetParameterCountLong_autogen0(network);
    private static _GetParameterCountLong_autogen1(network, options);
    private static _GetParameterCountLong_autogen2(node, key);
    private static _utt_x_(p_autogen6);
    private static _utu_x_(p_autogen15, p_autogen16, p_autogen17, p_autogen18);
    private static _utv_x_(p_autogen19, p_autogen20);
}
/**
*  Options for {@link com.bayesserver.ParameterCounter}.
*/
export declare class ParameterCountOptions {
    static readonly _Ceb_x_: boolean;
    private _Cec_x_;
    /**
*  Gets a value indicating whether null distributions are excluded from the parameter count.

* @return {boolean} <code>true</code> if null distributions should be excluded; otherwise, <code>false</code>.
*/
    /**
*  Sets a value indicating whether null distributions are excluded from the parameter count.
*
* @param {boolean} value <code>true</code> if null distributions should be excluded; otherwise, <code>false</code>.
*/
    excludeNullDistributions: boolean;
}
/**
*  The propagation method used during inference.
*/
export declare class PropagationMethod {
    /**
*  Sum propagation is the default method, used to perform standard probabilistic inference.
*/
    static readonly Sum: PropagationMethod;
    /**
*  Max propagation is used to determine the most probable configuration of discrete variables, given any evidence entered.  Also known as Most Probable Explanation (MPE).
*/
    static readonly Max: PropagationMethod;
}
/**
*  Represents a state of a variable.  E.g. the discrete variable Gender might have two states, Male and Female.
*
* Note that a continuous variable always has a single state.
*/
export declare class State {
    private _Ced_x_;
    private _Cee_x_;
    private _Cef_x_;
    private _Ceg_x_;
    private _Ceh_x_;
    private _Cfa_x_;
    private _Cfb_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.State} class.
*/
    constructor();
    /**
*  Initializes a new instance of the {@link com.bayesserver.State} class with the specified [name].
*
* @param {string} name The name for the state.  Can be null.
*/
    constructor(name: string);
    /**
*  Initializes a new instance of the {@link com.bayesserver.State} class with the specified [name] and [value].
*
* @param {string} name The name for the state.  Can be null.
*
* @param {object} value Optional value for the state.  When the state is added to a variable, this value must be compatible with the {@link com.bayesserver.StateValueType} set on the variable.
*/
    constructor(name: string, value: any);
    private _cons_autogen0();
    private _cons_autogen1(name);
    private _cons_autogen2(name, value);
    /**
*  Gets custom properties associated with this instance.
*
*  Custom properties allow storage of custom information, which will be saved with the network.
*/
    readonly customProperties: CustomPropertyCollection;
    /**
*  Gets an optional description for the state.
*/
    /**
*  Sets an optional description for the state.
*/
    description: string;
    /**
*  Gets the index of the state in a variable's {@link com.bayesserver.Variable#getStates} collection.  Equals -1 if the {@link com.bayesserver.State} does not belong to a variable.
*/
    readonly index: number;
    _setIndex(value: number): void;
    /**
*  Gets the name of the state.
*/
    /**
*  Sets the name of the state.
*/
    name: string;
    /**
*  Gets the {@link com.bayesserver.StateCollection} the state belongs to, if any.

* @return {StateCollection} The {@link com.bayesserver.StateCollection} that this instance belongs to.  Can be null.
*/
    readonly states: StateCollection;
    _setStates(value: StateCollection): void;
    /**
*  Gets an optional value for a state, such as an interval for discretized variables.
*
* When a {@link com.bayesserver.State} is added to a {@link com.bayesserver.Variable} this value must be compatible with the {@link com.bayesserver.StateValueType} set on the variable.
*/
    /**
*  Sets an optional value for a state, such as an interval for discretized variables.
*
* When a {@link com.bayesserver.State} is added to a {@link com.bayesserver.Variable} this value must be compatible with the {@link com.bayesserver.StateValueType} set on the variable.
*/
    value: any;
    /**
*  Gets the {@link com.bayesserver.Variable} the state belongs to, if any.
*
* If this instance is a child of another state, the state hierarchy is traversed to reach the variable of the root state, if any.

* @return {Variable} The {@link com.bayesserver.Variable} that this instance belongs to.  Can be null.
*/
    readonly variable: Variable;
    _setVariable(value: Variable): void;
    /**
*  Copies this instance.

* @return {State} A new {@link com.bayesserver.State} instance.
*/
    copy(): State;
    /**
*  Returns the name of the state, or an empty string if the name is null.

* @return {string}  A {@link String} containing the name of the state which is empty if the name is null.
*/
    toString(): string;
    private _uuu_x_();
    private _uuv_x_(p_autogen6);
    static _uus_x_(p_autogen3: any, p_autogen4: StateValueType | null): void;
    private static _uut_x_(p_autogen5);
}
/**
*  Represents a collection of states belonging to a {@link com.bayesserver.Variable}.
*
* Note that a continuous variable always has a single state.

* @see com.bayesserver.State
*/
export declare class StateCollection implements IList<State> {
    private _Cfc_x_;
    private _items;
    private _Cfd_x_;
    private _Cfe_x_;
    constructor(p_autogen0: Variable, p_autogen1: boolean);
    constructor(p_autogen2: Variable, p_autogen3: boolean, p_autogen4: State);
    private _cons_autogen0(p_autogen0, p_autogen1);
    private _cons_autogen1(p_autogen2, p_autogen3, p_autogen4);
    /**
* @inheritDoc
*/
    _2ad2e5f4b2884a52bf8bfc07ce8953d3(): void;
    /**
* @inheritDoc
*/
    readonly size: number;
    /**
* @inheritDoc
*/
    readonly isReadOnly: boolean;
    [Symbol.iterator](): Iterator<State>;
    /**
*  Gets the {@link com.bayesserver.Variable} this collection belongs to.  This is null if this is a child state collection.

* @return {Variable} The variable that owns this collection.
*/
    readonly variable: Variable;
    /**
*  Performs a case sensitive lookup.
*
* @param {string} name The name of the {@link com.bayesserver.State} to find.

* @return {State} A {@link com.bayesserver.State} with the specified name if found; otherwise null.
*/
    get(name: string): State;
    /**
*  Performs a case sensitive lookup.
*
* @param {string} name The name of the {@link com.bayesserver.State} to find.
*
* @param {boolean} throwIfNotFound When <code>true</code> throws an exception if the name is not found.

* @return {State} The {@link com.bayesserver.State} with the specified name; otherwise null.
*/
    get(name: string, throwIfNotFound: boolean): State;
    /**
*  Gets the {@link com.bayesserver.State} at the specified index.

* @return {State} The state.
*/
    get(index: number): State;
    private _get_autogen0(name);
    private _get_autogen1(name, throwIfNotFound);
    private _get_autogen2(index);
    /**
*  Finds the state whose {@link com.bayesserver.State#getValue value}/> matches the given [value], or null if a match is not found.
*
*  For discretized variables, each {@link com.bayesserver.State#getValue} is an {@link com.bayesserver.Interval}, and this method returns the state whose interval contains the given [value].
*
* @param {object} value The value to match to a {@link com.bayesserver.State#getValue}.

* @return {State} The matching {@link com.bayesserver.State} or null if a match is not found.
*/
    findByValue(value: any): State;
    /**
*  Sets the {@link com.bayesserver.State} at the specified index.
*
* @param {State} value The state.
*/
    set(index: number, value: State): void;
    private _addInternal(item);
    /**
* @inheritDoc
*/
    clear(): void;
    /**
*  Determines whether a {@link com.bayesserver.State} is in the collection.  The operation is O(1).
*
* @param {State} item The {@link com.bayesserver.State} to locate in the collection. The value can be null.

* @return {boolean} true if [item] is found in the collection; otherwise, false.
*/
    includes(item: State): boolean;
    /**
*  Determines the index of a specific {@link com.bayesserver.State} in the collection.  This operation is O(1).
*
* @param {State} item The state to find. The value can be null.

* @return {number} The index of the state in the collection, or -1 if not found.
*/
    indexOf(item: State): number;
    /**
*  Inserts an element into the collection at the specified index.
*
* @param {number} index The zero based index at which to add the element.
*
* @param {State} item The item to insert.  Cannot be null.

* @exception ReferenceError Raised when [item] is null.

* @exception Error Raised if the state already belongs to a network.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    insert(index: number, item: State): void;
    /**
* @inheritDoc
*/
    remove(item: State): boolean;
    /**
*  Removes an element from the collection at the specified index.
*
* @param {number} index The zero based index at which to remove the element.

* @exception RangeError index is less than 0.-or-index is equal to or greater than the collection count.
*/
    removeAt(index: number): State;
    _uvq_x_(p_autogen17: State, p_autogen18: string, p_autogen19: string): void;
    _uvr_x_(p_autogen20: string): void;
    private _uvs_x_();
    private _uvt_x_(p_autogen21);
    private _uvu_x_(p_autogen22, p_autogen23);
    private _uvv_x_(p_autogen24, p_autogen25);
    private _vqq_x_(p_autogen26, p_autogen27, p_autogen28, p_autogen29);
    private _vqr_x_(p_autogen30, p_autogen31, p_autogen32, p_autogen33);
    private _vqs_x_(p_autogen34);
    private _vqt_x_();
    _vqu_x_(): void;
    private _vqv_x_(p_autogen35);
    push(...items: State[]): number;
}
/**
*  Identifies a {@link com.bayesserver.State} and contextual information such as the time (zero based).
*/
export declare class StateContext {
    private _Cff_x_;
    private _Cfg_x_;
    /**
*  Initializes a new instance of {@link com.bayesserver.StateContext}.
*
* @param {State} state The State.
*
* @param {?number} time The associated time if the state belongs to a temporal node, or null otherwise.
*/
    constructor(state: State, time: number | null);
    /**
*  Gets the State.
*/
    readonly state: State;
    /**
*  Gets the zero based time associated with the state if the state belongs to a temporal node, or null otherwise.
*/
    readonly time: number | null;
}
/**
*  The type of value represented by a {@link com.bayesserver.State}.
*
*  This setting determines the type of values that {@link com.bayesserver.State#getValue} can have.
*/
export declare class StateValueType {
    /**
*  A {@link com.bayesserver.State} has no value.  It will still have a name however.
*/
    static readonly None: StateValueType;
    /**
*  The {@link com.bayesserver.State} value is an interval specified using double precision numbers.
*/
    static readonly DoubleInterval: StateValueType;
    /**
*  A {@link com.bayesserver.State} can have a integer value.
*/
    static readonly Integer: StateValueType;
    /**
*  A {@link com.bayesserver.State} can have a boolean value.
*/
    static readonly Boolean: StateValueType;
}
/**
*  Used to represent conditional probability distributions, joint probability distributions and more general potentials, over a number of discrete variables.
*
*  The variables in a {@link com.bayesserver.Table} are automatically sorted by time (if any) and {@link com.bayesserver.Variable}.  This is for computational reasons.
* <p> The {@link com.bayesserver.Table} class stores it's values in a zero based 1-dimensional array, and the right most variable's states toggle fastest. For example if a {@link com.bayesserver.Table} contains 3 binary variables {A,B,C} all with states {T,F} the table layout would be as follows.</p>
<div><table><tr><th>A</th><th>B</th><th>C</th><th>Index</th></tr><tr><td>T</td><td>T</td><td>T</td><td>0</td></tr><tr><td>T</td><td>T</td><td>F</td><td>1</td></tr><tr><td>T</td><td>F</td><td>T</td><td>2</td></tr><tr><td>T</td><td>F</td><td>F</td><td>3</td></tr><tr><td>F</td><td>T</td><td>T</td><td>4</td></tr><tr><td>F</td><td>T</td><td>F</td><td>5</td></tr><tr><td>F</td><td>F</td><td>T</td><td>6</td></tr><tr><td>F</td><td>F</td><td>F</td><td>7</td></tr></table></div> If a different variable ordering is required see the {@link com.bayesserver.TableIterator} and {@link com.bayesserver.TableAccessor} classes.

* @see com.bayesserver.TableAccessor

* @see com.bayesserver.TableIterator
*/
export declare class Table implements IDistribution {
    private _Cfh_x_;
    private _Cga_x_;
    /**
* @inheritDoc
*/
    _39d9d5f7317c4bb79bd3c1e43b2b4a43: string | null;
    private _Cgb_x_;
    private _Cgc_x_;
    private _Cgd_x_;
    private _Cge_x_;
    private _Cgf_x_;
    private _Cgg_x_;
    private _Cgh_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class, with the same structure as an existing [table], copying the values if requested.
*
* @param {Table} table The table to copy.
*
* @param {boolean} copyValues if set to <code>true</code> the values from [table] are copied, otherwise all values are initialized to zero.

* @exception ReferenceError Raised if [table] is null.
*/
    constructor(table: Table, copyValues: boolean);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class, with the same structure as an existing [table], copying the values if requested, and optionally shifting any times.
*
* @param {Table} table The table to copy.
*
* @param {boolean} copyValues if set to <code>true</code> the values from [table] are copied, otherwise all values are initialized to zero.
*
* @param {?number} timeShift If supplied shifts any times embedded in the source table by the specified number of units.

* @exception ReferenceError Raised if [table] is null.
*/
    constructor(table: Table, copyValues: boolean, timeShift: number | null);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with a single {@link com.bayesserver.Variable}.  All values are initialized to zero.
*
* @param {Variable} variable The variable.

* @exception ReferenceError Raised when [variable] is null.
*/
    constructor(variable: Variable);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class from a single {@link com.bayesserver.VariableContext}.  All values are initialized to zero.
*
* @param {VariableContext} variableContext The variable context.

* @exception ReferenceError Raised when [variableContext] is null.
*/
    constructor(variableContext: VariableContext);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with the specified variables, at an optional time.  All values are initialized to zero.
*
* @param {IList<Variable>} variables The variables.
*
* @param {?number} time The time for the variables.  Can be null.

* @exception Error Raised if a duplicate variable/time combination is detected in [variables], or if a variable has zero states.
*/
    constructor(variables: IList<Variable>, time: number | null);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with the specified variables, at an optional time.  All values are initialized to zero.
*
* @param {IList<Variable>} variables The variables.
*
* @param {?number} time The time for the variables.  Can be null.
*
* @param {HeadTail} headTail Specifies whether the variables should be marked as Head or Tail.

* @exception Error Raised if a duplicate variable/time combination is detected in [variables], or if a variable has zero states.
*/
    constructor(variables: IList<Variable>, time: number | null, headTail: HeadTail);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with the variables specified in [variableContexts].  All values are initialized to zero.
*
* @param {VariableContextCollection} variableContexts The variables, times, and head/tail specifications to include in the distribution.

* @exception Error Raised if a duplicate variable-time combination is detected in [variableContexts], or if a variable has zero states.
*/
    constructor(variableContexts: VariableContextCollection);
    /**
*  For internal use only.
*/
    constructor(variableContexts: VariableContext[], copy: boolean);
    constructor(variableContexts: VariableContext[]);
    constructor(variableContexts: IList<VariableContext>);
    constructor(variableContexts: IList<VariableContext>, headTail: HeadTail);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with the specified variables.  All values are initialized to zero.
*
* @param {Variable[]} variables The variables.

* @exception ReferenceError Raised if [variables] is null.

* @exception Error Raised if a duplicate variable-time combination is detected in [variables], or if a variable has zero states.
*/
    constructor(variables: Variable[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with [count] variable contexts taken from [buffer].  All values are initialized to zero.
*
* @param {VariableContext[]} buffer The buffer of {@link com.bayesserver.VariableContext} instances.
*
* @param {number} count The number of items to read from [buffer].

* @exception ReferenceError Raised if [buffer] is null.

* @exception Error Raised if a null or duplicate variable-time combination is detected in [buffer], or if a variable has zero states.
*/
    constructor(buffer: VariableContext[], count: number);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with [count] variable contexts taken from [buffer].  All values are initialized to zero.
*
* @param {VariableContext[]} buffer The buffer of {@link com.bayesserver.VariableContext} instances.
*
* @param {number} count The number of items to read from [buffer].
*
* @param {HeadTail} headTail Overrides the Head or Tail value found in each {@link com.bayesserver.VariableContext}.

* @exception ReferenceError Raised if [buffer] is null.

* @exception Error Raised if a null or duplicate variable-time combination is detected in [buffer], or if a variable has zero states.
*/
    constructor(buffer: VariableContext[], count: number, headTail: HeadTail);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with the specified node variable at the specified time.  All values are initialized to zero.
*
* @param {Node} node The node whose variable is used to construct the {@link com.bayesserver.Table}.
*
* @param {?number} time The time for the node variable.  Can be null.

* @exception Error Raised if a node variable has zero states.
*/
    constructor(node: Node, time: number | null);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with a single {@link com.bayesserver.Variable} and time.  All values are initialized to zero.
*
* @param {Variable} variable The variable.
*
* @param {?number} time The variable time. Can be null for non temporal nodes.

* @exception ReferenceError Raised when [variable] is null.
*/
    constructor(variable: Variable, time: number | null);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with all the variables from the supplied nodes.  All values are initialized to zero.
*
* @param {IList<Node>} nodes The {@link com.bayesserver.Node} instances.

* @exception ReferenceError Raised if [nodes] is null.

* @exception Error Raised if a null or duplicate variable is detected or if a variable has zero states.
*/
    constructor(nodes: IList<Node>);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with all the variables from the supplied nodes.  All values are initialized to zero.
*
* @param {Node[]} nodes The {@link com.bayesserver.Node} instances.

* @exception ReferenceError Raised if [nodes] is null.

* @exception Error Raised if a null or duplicate variable is detected or if a variable has zero states.
*/
    constructor(nodes: Node[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with all the variables from the supplied nodes.  All values are initialized to zero.
*
* @param {IList<Node>} nodes The {@link com.bayesserver.Node} instances.
*
* @param {HeadTail} headTail Specifies whether the node variables should be marked as Head or Tail.

* @exception ReferenceError Raised if [nodes] is null.

* @exception Error Raised if a null or duplicate variable is detected or if a variable has zero states.
*/
    constructor(nodes: IList<Node>, headTail: HeadTail);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with all the variables from the supplied nodes.  All values are initialized to zero.
*
* @param {Node[]} nodes The {@link com.bayesserver.Node} instances.
*
* @param {HeadTail} headTail Specifies whether the node variables should be marked as Head or Tail.

* @exception ReferenceError Raised if [nodes] is null.

* @exception Error Raised if a null or duplicate variable is detected or if a variable has zero states.
*/
    constructor(nodes: Node[], headTail: HeadTail);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class, copying the [table] passed in.
*
* @param {Table} table The table to copy.

* @exception ReferenceError Raised if [table] is null.
*/
    constructor(table: Table);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class, copying the [table] passed in, however adjusting any times by the [timeShift].
*
* @param {Table} table The table to copy.
*
* @param {?number} timeShift The number of units to shift any time values associated with variables.

* @exception ReferenceError Raised if [table] is null.
*/
    constructor(table: Table, timeShift: number | null);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Table} class with the specified node variables.  All values are initialized to zero.
*
* @param {Node} node The node whose variables are used to construct the {@link com.bayesserver.Table}.

* @exception Error Raised if a node variable has zero states.
*/
    constructor(node: Node);
    private _cons_autogen0(table, copyValues);
    private _cons_autogen1(table, copyValues, timeShift);
    private _cons_autogen2(variable);
    private _cons_autogen3(variableContext);
    private _cons_autogen4(variables, time);
    private _cons_autogen5(variables, time, headTail);
    private _cons_autogen6(variableContexts);
    private _cons_autogen7(variableContexts, copy);
    private _cons_autogen8(variableContexts);
    private _cons_autogen9(variableContexts);
    private _cons_autogen10(variableContexts, headTail);
    private _cons_autogen11(variables);
    private _cons_autogen12(buffer, count);
    private _cons_autogen13(buffer, count, headTail);
    private _cons_autogen14(node, time);
    private _cons_autogen15(variable, time);
    private _cons_autogen16(nodes);
    private _cons_autogen17(nodes);
    private _cons_autogen18(nodes, headTail);
    private _cons_autogen19(nodes, headTail);
    private _cons_autogen20(table);
    private _cons_autogen21(table, timeShift);
    private _cons_autogen22(node);
    /**
*  Returns any non zero table values, keyed by index.
*/
    nonZero(values: ITableNonZeroValues): void;
    /**
*  Gets the maximum table value, and the index at which it occurs.

* @return {TableMaxValue} The maximum table value and the zero based index at which it occurs.
*/
    getMaxValue(): TableMaxValue;
    /**
*  Shifts any times associated with the table variables by the specified number of units.
*
* @param {number} units The number of time units to shift.  Can be negative if required.

* @exception Error Raised if this instance is read only.
*/
    timeShift(units: number): void;
    /**
* @inheritDoc
*/
    /**
* @inheritDoc
*/
    locked: boolean;
    /**
* @inheritDoc
*/
    isReadOnly(): boolean;
    /**
*  Randomizes the distribution such that each parent combination sums to 1.
*
* @param {IRandom} random Random number generator.

* @exception Error Raised if this instance is read only.
*/
    randomize(random: IRandom): void;
    private _vrr_x_();
    /**
*  Normalizes the distribution such that each parent combination sums to 1.
*
* @param {boolean} unifyZeroSum If true, applies a uniform distribution to any parent combinations that sum to zero.

* @return {boolean} <code>false</code> if a zero sum was found for any parent combination; <code>true</code> otherwise

* @exception Error Raised if this instance is read only.
*/
    normalize(unifyZeroSum: boolean): boolean;
    /**
*  Normalizes the distribution such that each parent combination sums to 1.

* @return {boolean} <code>false</code> if a zero sum was found for any parent combination; <code>true</code> otherwise.

* @exception Error Raised if this instance is read only.
*/
    normalize(): boolean;
    private _Normalize_autogen0(unifyZeroSum);
    private _Normalize_autogen1();
    /**
* @inheritDoc
*/
    toString(): string;
    private _vrt_x_(p_autogen42);
    readonly outer: IDistribution;
    _vru_x_(p_autogen47: IDistribution): void;
    /**
*  Creates a copy of the distribution.  The new distribution will not have an owner.

* @return {IDistribution} A copy of this instance.
*/
    copy(): IDistribution;
    /**
*  Creates a copy of the distribution, and shifts any times associated with variables by the specified amount.  The new distribution will not have an owner.
*
* @param {?number} timeShift The amount to shift any times present in the distribution.  Can be negative.

* @return {IDistribution}  A copy of this instance, with shifted times.
*/
    copy(timeShift: number | null): IDistribution;
    private _Copy_autogen0();
    private _Copy_autogen1(timeShift);
    /**
*  Gets the current owner, if assigned to a node.  A distribution cannot be modified when it is assigned to a node.

* @return {Node} The owner, or null if not assigned to a node.
*/
    readonly owner: Node;
    _setOwner(value: Node): void;
    /**
*  Returns true if none of the values in the {@link com.bayesserver.Table} equal zero, or false otherwise.

* @return {boolean} True if none of the values are zero; false otherwise.
*/
    areAllValuesNonZero(): boolean;
    private _vsq_x_();
    /**
*  Copies values from the array into the table.
*
* @param {number[]} data Values to copy.  The array can be shorter or longer than the {@link com.bayesserver.Table#size}.

* @exception ReferenceError Raised if [data] is null.

* @exception Error Raised if this instance is read only.
*/
    copyFrom(data: number[]): void;
    /**
*  Adds the values from another table into this instance.  Only the
* @see com.bayesserver.Table#size
of each table need match.
*
* @param {Table} source A table whose
* @see com.bayesserver.Table#size
matches this instance.

* @exception ReferenceError Raised if the [source] is null.

* @exception Error Raised if the table counts do not match

* @exception Error Raised if this instance is read only.
*/
    add(source: Table): void;
    /**
*  Copies all values from this instance to the destination {@link com.bayesserver.Table}.
*
* @param {Table} destination The destination table, which can have a count greater than or equal to this instance.

* @exception Error Raised if the destination table is read only.
*/
    copyTo(destination: Table): void;
    /**
*  Copies the table values to an array.
*
* @param {number[]} destination The destination array, which must have length equal to or greater than this the count of this instance.

* @exception ReferenceError Raised if [destination] is null.

* @exception Error Raised if [destination] is too short.
*/
    copyTo(destination: number[]): void;
    private _CopyTo_autogen0(destination);
    private _CopyTo_autogen1(destination);
    /**
*  Adds the specified value onto all table elements.
*
* @param {number} value The value to add.  Can be negative.
*/
    addAll(value: number): void;
    /**
*  Sets all values in the {@link com.bayesserver.Table} to a specified value.
*
* @param {number} value The value to set all elements to.

* @exception Error Raised if this instance is read only.
*/
    setAll(value: number): void;
    /**
*  Gets the number of times each state is repeated for a {@link com.bayesserver.Variable} in the {@link com.bayesserver.Table} layout.   See {@link com.bayesserver.Table} for details on layout.
*
* @param {number} index The index into {@link com.bayesserver.Table#getSortedVariables}.

* @return {number} The repeat count for each state.
*/
    stateRepeat(index: number): number;
    /**
*  Gets the number of states of a variable at the time this instance was constructed.
*
* @param {number} index The index into {@link com.bayesserver.Table#getSortedVariables}.

* @return {number} The state count.
*/
    stateCount(index: number): number;
    /**
*  The data count in the {@link com.bayesserver.Table}.  Equals the product of states for each {@link com.bayesserver.Variable}.

* @return {number} The data count.
*/
    readonly size: number;
    /**
*  Gets the table value corresponding to the given states.
*
* @param {State[]} states The variable states that together specify a unique value in this table.
*
*  For example, if the table represents P(A|B) we can access the value corresponding to P(A=True | B=False) by passing in the states A=True and B=False.

* @return {number} The table value.
*/
    get(states: State[]): number;
    /**
*  Gets the table value corresponding to the given states and associated times.
*
* @param {StateContext[]} states The variable states and times that together specify a unique value in this table.
*/
    get(states: StateContext[]): number;
    /**
*  Gets the {@link com.bayesserver.Table} value at the specified index into the 1-dimensional array.  See {@link com.bayesserver.Table} for information on how entries are stored.
*
* @param {number} index The index into the underlying 1-dimensional array.

* @return {number} The value at the specified index.
*/
    get(index: number): number;
    private _get_autogen0(states);
    private _get_autogen1(states);
    private _get_autogen2(index);
    /**
*  Sets the table value corresponding to the given states.
*
* @param {State[]} states The variable states that together specify a unique value in this table.
*
*  For example, if the table represents P(A|B) we can access the value corresponding to P(A=True | B=False) by passing in the states A=True and B=False.
*/
    set(value: number, states: State[]): void;
    /**
*  Sets the table value corresponding to the given states and associated times.
*
* @param {StateContext[]} states The variable states and times that together specify a unique value in this table.
*/
    set(value: number, states: StateContext[]): void;
    /**
*  Sets the {@link com.bayesserver.Table} value at the specified index into the 1-dimensional array.  See {@link com.bayesserver.Table} for information on how entries are stored.
*
* @param {number} index The index into the underlying 1-dimensional array.
*/
    set(index: number, value: number): void;
    private _set_autogen0(value, states);
    private _set_autogen1(value, states);
    private _set_autogen2(index, value);
    /**
*  Gets the index of the table element that corresponds to a particular combination of states.
*
* @param {State[]} states A state for each variable.

* @return {number} The index corresponding to the states.
*/
    getSortedIndex(states: State[]): number;
    /**
*  Gets the index of the table element that corresponds to a particular combination of states and their times.
*
* @param {StateContext[]} stateContexts A state and time for each variable. Time can be null for non temporal variables.

* @return {number} The index corresponding to the states.
*/
    getSortedIndex(stateContexts: StateContext[]): number;
    private _GetSortedIndex_autogen0(states);
    private _GetSortedIndex_autogen1(stateContexts);
    /**
*  Gets the collection of variables in the distribution, sorted by time (which may be null) and the order in which variables were created.
*
*  All variables in each distribution are sorted, based on their creation order.  This is for computational reasons. If you want to access the values with respect to a different variable ordering, see the {@link com.bayesserver.TableIterator} and {@link com.bayesserver.TableAccessor} classes.

* @return {VariableContextCollection} Variables sorted by time and the order variables were created.
*/
    readonly sortedVariables: VariableContextCollection;
    /**
*  Calculates the sum of all values in the {@link com.bayesserver.Table}.

* @return {number} The sum of all table values.
*/
    sum(): number;
    readonly table: Table;
    /**
*  Creates a new distribution by dividing this instance by the [subset].  Also known as the complement.
*
* If the resulting distribution were subsequently multiplied by [subset], the result would be equivalent to this instance.
*
* @param {IDistribution} subset The subset to divide by.

* @return {IDistribution} The new distribution.

* @exception ReferenceError Raised if [subset] is null.
*/
    divide(subset: IDistribution): IDistribution;
    /**
*  Divides this instance in place by the [subset].  Also known as the complement.
*
*
* <p> The term 'in place' means that this instance is modified, instead of creating a new distribution.</p>
If the resulting distribution were subsequently multiplied by [subset], the result would be equivalent to this instance.
*
* @param {Table} subset The subset to divide by.

* @exception ReferenceError Raised if [subset] is null.

* @exception Error Raised if this instance is read only.
*/
    divideInPlace(subset: Table): void;
    /**
*  Creates a table with a subset of variables by setting hard evidence on one or more variables.
*
* [values] should contain one entry for each
* @see com.bayesserver.VariableContext
in the distribution, however entries can be null.
*
* @param {?number[]} values An array of nullable state indexes, one for each variable in this {@link com.bayesserver.Table} instance.  Values are null for variables with no evidence.

* @return {IDistribution} The {@link com.bayesserver.Table} of instantiated values.  I.e.  The table after some variables have been set.

* @exception ReferenceError Raised if [values] is null.

* @exception Error Raised if the length of [values] does not equal the number of variables in the table.

* @exception Error Raised if this instance is read only.
*/
    instantiate(values: (number | null)[]): IDistribution;
    private _vst_x_(p_autogen80);
    /**
*  Marginalizes (sums) the [superset] into this instance.
*
*  This method initializes all values to zero before performing the marginalization. If you know that all the values are zero (e.g. when a {@link com.bayesserver.Table} is first created), call an overloaded version of this method.
*
* @param {IDistribution} superset A {@link com.bayesserver.Table} whose variables form a superset of the variables in this instance.

* @exception ReferenceError Raised if [superset] is null.

* @exception Error Raised if this instance is read only, or if any variables are no longer sorted correctly due to modifications of the network.

* @exception Error Raised if [superset] does not contain all the variables in this instance.
*/
    marginalize(superset: IDistribution): void;
    /**
*  Marginalizes (sums) the [superset] into this instance.
*
*  This method initializes all values to zero before performing the marginalization. If you know that all the values are zero (e.g. when a {@link com.bayesserver.Table} is first created), call an overloaded version of this method.
*
* @param {IDistribution} superset A {@link com.bayesserver.Table} whose variables form a superset of the variables in this instance.
*
* @param {PropagationMethod} propagation The propagation method to use during marginalization.

* @exception ReferenceError Raised if [superset] is null.

* @exception Error Raised if this instance is read only, or if any variables are no longer sorted correctly due to modifications of the network.

* @exception Error Raised if [superset] does not contain all the variables in this instance.
*/
    marginalize(superset: IDistribution, propagation: PropagationMethod): void;
    /**
*  Marginalizes (sums) the [superset] into this instance.
*
*  This method initializes all values to zero before performing the marginalization. If you know that all the values are zero (e.g. when a {@link com.bayesserver.Table} is first created), call an overloaded version of this method.
*
* @param {Table} superset A {@link com.bayesserver.Table} whose variables form a superset of the variables in this instance.

* @exception ReferenceError Raised if [superset] is null.

* @exception Error Raised if this instance is read only, or if any variables are no longer sorted correctly due to modifications of the network.

* @exception Error Raised if [superset] does not contain all the variables in this instance.
*/
    marginalize(superset: Table): void;
    /**
*  Marginalizes (sums) the [superset] into this instance.
*
*  This method initializes all values to zero before performing the marginalization. If you know that all the values are zero (e.g. when a {@link com.bayesserver.Table} is first created), call an overloaded version of this method.
*
* @param {Table} superset A {@link com.bayesserver.Table} whose variables form a superset of the variables in this instance.
*
* @param {PropagationMethod} propagation The propagation method to use during marginalization.

* @exception ReferenceError Raised if [superset] is null.

* @exception Error Raised if this instance is read only, or if any variables are no longer sorted correctly due to modifications of the network.

* @exception Error Raised if [superset] does not contain all the variables in this instance.
*/
    marginalize(superset: Table, propagation: PropagationMethod): void;
    /**
*  Marginalizes (sums) the [superset] into this instance.
*
* By default all table values are zero, however if the {@link com.bayesserver.Table} values are not zero the [initialize] parameter avoids the need to initialize all values in the distribution to 0 before performing the marginalization.
*
* @param {Table} superset A {@link com.bayesserver.Table} whose variables form a superset of the variables in this instance.
*
* @param {boolean} initialize Set to <code>true</code> if all values should be initialized to 0 before the marginalization.

* @exception ReferenceError Raised if [superset] is null.

* @exception Error Raised if this instance is read only, or if any variables are no longer sorted correctly due to modifications of the network.

* @exception Error Raised if [superset] does not contain all the variables in this instance.
*/
    marginalize(superset: Table, initialize: boolean): void;
    /**
*  Marginalizes (sums) the [superset] into this instance.
*
* By default all table values are zero, however if the {@link com.bayesserver.Table} values are not zero the [initialize] parameter avoids the need to initialize all values in the distribution to 0 before performing the marginalization.
*
* @param {Table} superset A {@link com.bayesserver.Table} whose variables form a superset of the variables in this instance.
*
* @param {boolean} initialize Set to <code>true</code> if all values should be initialized to 0 before the marginalization.
*
* @param {PropagationMethod} propagation The propagation method to use during marginalization.

* @exception ReferenceError Raised if [superset] is null.

* @exception Error Raised if this instance is read only, or if any variables are no longer sorted correctly due to modifications of the network.

* @exception Error Raised if [superset] does not contain all the variables in this instance.
*/
    marginalize(superset: Table, initialize: boolean, propagation: PropagationMethod): void;
    private _Marginalize_autogen0(superset);
    private _Marginalize_autogen1(superset, propagation);
    private _Marginalize_autogen2(superset);
    private _Marginalize_autogen3(superset, propagation);
    private _Marginalize_autogen4(superset, initialize);
    private _Marginalize_autogen5(superset, initialize, propagation);
    private _vsu_x_(p_autogen92, p_autogen93, p_autogen94, p_autogen95, p_autogen96);
    private _vsv_x_(p_autogen97, p_autogen98, p_autogen99);
    private _vtq_x_(p_autogen100, p_autogen101, p_autogen102, p_autogen103);
    private _vtr_x_(p_autogen104, p_autogen105, p_autogen106, p_autogen107, p_autogen108);
    private _vts_x_(p_autogen109, p_autogen110, p_autogen111);
    private _vtt_x_(p_autogen112, p_autogen113);
    /**
*  Marginalizes (sums) the combined [tables], without requiring the memory for the combined distribution.
*
*  This method uses very little memory, however in general will perform worse than the standard Marginalize routines.
*
* @param {Table[]} tables The tables whose combined distribution you wish to marginalize.

* @exception ReferenceError Raised if [tables] is null.

* @exception Error Raised if this instance is read only, or if any variables are no longer sorted correctly due to modifications of the network.
*/
    marginalizeLowMemory(tables: Table[]): void;
    /**
*  Marginalizes (sums) the combined [tables], without requiring the memory for the combined distribution.
*
*  This method uses very little memory, however in general will perform worse than the standard Marginalize routines.
*
* @param {Table[]} tables The tables whose combined distribution you wish to marginalize.
*
* @param {MarginalizeLowMemoryOptions} options Options governing the method, including cancellation.

* @exception ReferenceError Raised if [tables] is null.

* @exception Error Raised if this instance is read only, or if any variables are no longer sorted correctly due to modifications of the network.
*/
    marginalizeLowMemory(tables: Table[], options: MarginalizeLowMemoryOptions): void;
    private _MarginalizeLowMemory_autogen0(tables);
    private _MarginalizeLowMemory_autogen1(tables, options);
    /**
*  Creates a new distribution by multiplying this instance by another distribution.
*
* @param {IDistribution} distribution A distribution to multiply by.

* @return {IDistribution} A new combined distribution.

* @exception ReferenceError Raised if [distribution] is null.

* @exception Error Raised if the variables in [distribution] are not contained in this instance.
*/
    multiply(distribution: IDistribution): IDistribution;
    /**
*  Multiplies all values in the distribution by the specified value.
*
* @param {number} value The value to multiply by.

* @exception Error Raised if this instance is read only.
*/
    multiplyInPlace(value: number): void;
    /**
*  Multiplies the [subset] into this instance.
*
*
* <p> The term 'in place' means that this instance is modified, instead of creating a new distribution.</p>
By default all table values are zero, so if the {@link com.bayesserver.Table} needs to be initialized to 1 before multiplication use a different overload of this method.
*
* @param {Table} subset A {@link com.bayesserver.Table} whose variables form a subset of the variables in this instance.

* @exception ReferenceError Raised if [subset] is null.

* @exception Error Raised if this instance is currently read only, or if any variables are no longer sorted correctly due to modifications of the network.

* @exception Error Raised if the variables in [subset] are not contained in this instance.
*/
    multiplyInPlace(subset: Table): void;
    /**
*  Multiplies the [subset] into this instance.
*
*
* <p> The term 'in place' means that this instance is modified, instead of creating a new distribution.</p>
By default all table values are zero, so the [initialize] parameter avoids the need to initialize all values in the distribution to 1 before performing the multiplication.
*
* @param {Table} subset A {@link com.bayesserver.Table} whose variables form a subset of the variables in this instance.
*
* @param {boolean} initialize Set to <code>true</code> if all values should be initialized to 1 before the multiplication.

* @exception ReferenceError Raised if [subset] is null.

* @exception Error Raised if this instance is read only, or if any variables are no longer sorted correctly due to modifications of the network.

* @exception Error Raised if the variables in [subset] are not contained in this instance.
*/
    multiplyInPlace(subset: Table, initialize: boolean): void;
    private _MultiplyInPlace_autogen0(value);
    private _MultiplyInPlace_autogen1(subset);
    private _MultiplyInPlace_autogen2(subset, initialize);
    private _vtv_x_(p_autogen124, p_autogen125, p_autogen126, p_autogen127, p_autogen128);
    private static _vrs_x_(p_autogen23, p_autogen24, p_autogen25);
    private static _vrv_x_(p_autogen49, p_autogen50, p_autogen51, p_autogen52, p_autogen53);
    static _vsr_x_(p_autogen71: Table, p_autogen72: Table, p_autogen73: number | null, p_autogen74: number | null): number[];
    static _vss_x_(p_autogen75: number[], p_autogen76: Table): number[];
    private static _vtu_x_(p_autogen117, p_autogen118);
    static _vuq_x_(p_autogen129: number, p_autogen130: Table, p_autogen131: Table, p_autogen132: number[]): number;
    static _vur_x_(p_autogen133: number, p_autogen134: Table, p_autogen135: Table, p_autogen136: number[]): number;
}
/**
*  Allows random access to the values in a {@link com.bayesserver.Table}, using a preferred variable ordering, as opposed to the default sorted order specified in {@link com.bayesserver.Table#getSortedVariables}.

* @see com.bayesserver.TableIterator

* @see com.bayesserver.Table
*/
export declare class TableAccessor {
    private _Cha_x_;
    private _Chb_x_;
    private _Chc_x_;
    private _Chd_x_;
    private _Che_x_;
    private _Chf_x_;
    private _Chg_x_;
    private _Chh_x_;
    private _Daa_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableAccessor} class, allowing random access to [table] with a specified [order] for the variables.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {IList<Variable>} order The order in which the variables should be accessed.  The last variable's states toggle fastest.

* @see com.bayesserver.TableIterator

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if order does not contain the same variables as [table].
*/
    constructor(table: Table, order: IList<Variable>);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableAccessor} class, allowing random access to [table] with a specified [order] for the variables.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {Variable[]} order The order in which the variables should be accessed.  The last variable's states toggle fastest.

* @see com.bayesserver.TableIterator

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if order does not contain the same variables as [table].
*/
    constructor(table: Table, order: Variable[]);
    constructor(table: Table, order: IList<VariableContext>);
    constructor(table: Table, order: VariableContext[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableAccessor} class, allowing random access to [table] with a specified [order] for the variables.  Any times that are contained within the {@link com.bayesserver.VariableContextCollection} will be used.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {VariableContextCollection} order The order in which the variables should be accessed, including any timing information contained in the {@link com.bayesserver.VariableContextCollection}.  The last variable's states toggle fastest.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if order does not contain the same variables as [table].
*/
    constructor(table: Table, order: VariableContextCollection);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableAccessor} class, allowing random access to [table] with a specified [order] for the node variables.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {IList<Node>} order The order in which the node variables should be accessed.  The last variable's states toggle fastest.
*
* @param {IList<int?>} times The times for the node variables.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if the nodes in order do not contain the same variables as [table].
*/
    constructor(table: Table, order: IList<Node>, times: IList<number | null>);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableAccessor} class, allowing random access to [table] with a specified [order] for the node variables.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {Node[]} order The order in which the node variables should be accessed.  The last variable's states toggle fastest.
*
* @param {?number[]} times The times for the node variables.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if the nodes in order do not contain the same variables as [table].
*/
    constructor(table: Table, order: Node[], times: (number | null)[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableAccessor} class, allowing random access to [table] with a specified [order] for the variables at specified times.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {Variable[]} order The order in which the variables should be accessed.  The last variable's states toggle fastest.
*
* @param {?number[]} times The times for the variables.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if order does not contain the same variables as [table].
*/
    constructor(table: Table, order: Variable[], times: (number | null)[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableAccessor} class, allowing random access to [table] with a specified [order] for the variables at specified times.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {IList<Variable>} order The order in which the variables should be accessed.  The last variable's states toggle fastest.
*
* @param {IList<int?>} times The times for the variables.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if order does not contain the same variables as [table].
*/
    constructor(table: Table, order: IList<Variable>, times: IList<number | null>);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableAccessor} class, allowing random access to [table] with a specified [order] for the node variables.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {IList<Node>} order The order in which the node variables should be accessed.  The last variable's states toggle fastest.

* @see com.bayesserver.TableIterator

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if the nodes in order do not contain the same variables as [table].
*/
    constructor(table: Table, order: IList<Node>);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableAccessor} class, allowing random access to [table] with a specified [order] for the node variables.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {Node[]} order The order in which the node variables should be accessed.  The last variable's states toggle fastest.

* @see com.bayesserver.TableIterator

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if the nodes in order do not contain the same variables as [table].
*/
    constructor(table: Table, order: Node[]);
    private _cons_autogen0(table, order);
    private _cons_autogen1(table, order);
    private _cons_autogen2(table, order);
    private _cons_autogen3(table, order);
    private _cons_autogen4(table, order);
    private _cons_autogen5(table, order, times);
    private _cons_autogen6(table, order, times);
    private _cons_autogen7(table, order, times);
    private _cons_autogen8(table, order, times);
    private _cons_autogen9(table, order);
    private _cons_autogen10(table, order);
    private _vus_x_(p_autogen22, p_autogen23, p_autogen24);
    /**
*  Gets the underlying {@link com.bayesserver.Table}.

* @return {Table} The underlying {@link com.bayesserver.Table}.
*/
    readonly table: Table;
    /**
*  Copies values from an array into the underlying {@link com.bayesserver.Table} using the variable ordering of the {@link com.bayesserver.TableAccessor}, not the {@link com.bayesserver.Table#getSortedVariables}.
*
* @param {number[]} values An array of values to copy.

* @exception ReferenceError Raised if [values] is null.

* @exception Error Raised if [values] is too short.
*/
    copyFrom(values: number[]): void;
    /**
*  Gets the count of values in the underlying {@link com.bayesserver.Table}.

* @return {number} The count.
*/
    readonly size: number;
    /**
*  Gets the underlying {@link com.bayesserver.Table} value, using states corresponding to the order of variables in the {@link com.bayesserver.TableAccessor}.

* @return {number} The underlying {@link com.bayesserver.Table} value.
*/
    get(states: number[]): number;
    /**
*  Gets the underlying {@link com.bayesserver.Table} value, specified i.

* @return {number} The table value.
*/
    get(i: number): number;
    private _get_autogen0(states);
    private _get_autogen1(i);
    /**
*  Sets the underlying {@link com.bayesserver.Table} value, using states corresponding to the order of variables in the {@link com.bayesserver.TableAccessor}.
*
* @param {number} value The underlying {@link com.bayesserver.Table} value.
*/
    set(states: number[], value: number): void;
    /**
*  Sets the underlying {@link com.bayesserver.Table} value, specified i.
*
* @param {number} value The table value.
*/
    set(i: number, value: number): void;
    private _set_autogen0(states, value);
    private _set_autogen1(i, value);
    /**
*  Gets the states at the given position [i].  The position is relative to specified variable ordering in the {@link com.bayesserver.TableAccessor}.
*
* @param {number} i The position at which to retrieve the states.
*
* @param {number[]} states A buffer for the states, which is overwritten by the method.

* @exception ReferenceError Raised if [states] is null.

* @exception Error Raised if [states] is too short.
*/
    getStates(i: number, states: number[]): void;
    /**
*  Gets the {@link com.bayesserver.TableAccessor} row for the given states.  The row is relative to the specified variable ordering in the {@link com.bayesserver.TableAccessor}.
*
* @param {number[]} states The states.

* @return {number} The corresponding row in the {@link com.bayesserver.TableAccessor}.

* @exception ReferenceError [states] is null.

* @exception Error [states] length does not equal the number of variables in the {@link com.bayesserver.TableAccessor}.
*/
    getRow(states: number[]): number;
    /**
*  Gets the state at the given position [i] for the node given by [node].  The position is relative to the specified variable ordering in the {@link com.bayesserver.TableAccessor}.
*
* @param {number} i The position at which to retrieve the state.
*
* @param {number} node The node.

* @return {number} The state.
*/
    getState(i: number, node: number): number;
    private _vut_x_(p_autogen37);
    /**
*  Gets the equivalent index in the underlying table that corresponds to the index in the accessor.
*
* @param {number} i The accessor index.

* @return {number} The equivalent underlying table index.
*/
    getTableIndex(i: number): number;
}
/**
*  Allows sequential access to the values in a {@link com.bayesserver.Table}, using a preferred variable ordering, as opposed to the default sorted order specified in {@link com.bayesserver.Table#getSortedVariables}.

* @see com.bayesserver.TableAccessor

* @see com.bayesserver.Table
*/
export declare class TableIterator {
    private _Dab_x_;
    private _Dac_x_;
    private _Dad_x_;
    private _Dae_x_;
    private _Daf_x_;
    private _Dag_x_;
    private _Dah_x_;
    private _Dba_x_;
    private _Dbb_x_;
    private _Dbc_x_;
    private _Dbd_x_;
    private _Dbe_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableIterator} class, allowing sequential access to [table] with a specified [order] for the variables.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {IList<Variable>} order The order in which the variables should be accessed.  The last variable's states toggle fastest.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if order does not contain the same variables as [table].
*/
    constructor(table: Table, order: IList<Variable>);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableIterator} class, allowing sequential access to [table] with a specified [order] for the variables.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {Variable[]} order The order in which the variables should be accessed.  The last variable's states toggle fastest.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if order does not contain the same variables as [table].
*/
    constructor(table: Table, order: Variable[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableIterator} class, allowing sequential access to [table] with a specified [order] for the variables at specified times.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {Variable[]} order The order in which the variables should be accessed.  The last variable's states toggle fastest.
*
* @param {?number[]} times The times for the variables.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if order does not contain the same variables as [table].
*/
    constructor(table: Table, order: Variable[], times: (number | null)[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableIterator} class, allowing sequential access to [table] with a specified [order] for the variables at specified times.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {IList<Variable>} order The order in which the variables should be accessed.  The last variable's states toggle fastest.
*
* @param {IList<int?>} times The times for the variables.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if order does not contain the same variables as [table].
*/
    constructor(table: Table, order: IList<Variable>, times: IList<number | null>);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableIterator} class, allowing sequential access to [table] with a specified [order] for the node variables.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {IList<Node>} order The order in which the node variables should be accessed.  The last variable's states toggle fastest.
*
* @param {IList<int?>} times The times for the variables.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if the nodes in order do not contain the same variables as [table].
*/
    constructor(table: Table, order: IList<Node>, times: IList<number | null>);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableIterator} class, allowing sequential access to [table] with a specified [order] for the node variables.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {Node[]} order The order in which the node variables should be accessed.  The last variable's states toggle fastest.
*
* @param {?number[]} times The times for the variables.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if the nodes in order do not contain the same variables as [table].
*/
    constructor(table: Table, order: Node[], times: (number | null)[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableIterator} class, allowing sequential access to [table] with a specified [order] for the variables.  Any times that are contained within the {@link com.bayesserver.VariableContextCollection} will be used.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {VariableContextCollection} order The order in which the variables should be accessed, including any timing information contained in the {@link com.bayesserver.VariableContextCollection}.  The last variable's states toggle fastest.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if order does not contain the same variables as [table].
*/
    constructor(table: Table, order: VariableContextCollection);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableIterator} class, allowing sequential access to [table] with a specified [order] for the node variables.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {IList<Node>} order The order in which the node variables should be accessed.  The last variable's states toggle fastest.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if the nodes in order do not contain the same variables as [table].
*/
    constructor(table: Table, order: IList<Node>);
    /**
*  Initializes a new instance of the {@link com.bayesserver.TableIterator} class, allowing sequential access to [table] with a specified [order] for the node variables.
*
* @param {Table} table The table whose values are to be accessed.
*
* @param {Node[]} order The order in which the node variables should be accessed.  The last variable's states toggle fastest.

* @exception ReferenceError Raised if either [table] or [order] is null.

* @exception Error Raised if the nodes in order do not contain the same variables as [table].
*/
    constructor(table: Table, order: Node[]);
    constructor(table: Table, order: IList<VariableContext>);
    constructor(table: Table, order: VariableContext[]);
    private _cons_autogen0(table, order);
    private _cons_autogen1(table, order);
    private _cons_autogen2(table, order, times);
    private _cons_autogen3(table, order, times);
    private _cons_autogen4(table, order, times);
    private _cons_autogen5(table, order, times);
    private _cons_autogen6(table, order);
    private _cons_autogen7(table, order);
    private _cons_autogen8(table, order);
    private _cons_autogen9(table, order);
    private _cons_autogen10(table, order);
    private _vuu_x_(p_autogen26, p_autogen27, p_autogen28);
    /**
*  Gets the count of values in the underlying {@link com.bayesserver.Table}.

* @return {number} The count.
*/
    readonly size: number;
    /**
*  Gets the underlying {@link com.bayesserver.Table}.

* @return {Table} The underlying {@link com.bayesserver.Table}.
*/
    readonly table: Table;
    /**
*  Gets the underlying {@link com.bayesserver.Table} value at the current position of the iterator.

* @return {number} The underlying {@link com.bayesserver.Table} value.
*/
    /**
*  Sets the underlying {@link com.bayesserver.Table} value at the current position of the iterator.
*
* @param {number} value The underlying {@link com.bayesserver.Table} value.
*/
    value: number;
    /**
*  Moves the iterator to the next value, with respect to the {@link com.bayesserver.TableIterator} node order.
*/
    increment(): void;
    /**
*  Gets the current position of the iterator.  For the position in the underlying {@link com.bayesserver.Table} see {@link com.bayesserver.TableIterator#getTableRow}.

* @return {number} The row.
*/
    readonly row: number;
    /**
*  Gets the position of the iterator in the underlying {@link com.bayesserver.Table}.  For the position of the iterator see {@link com.bayesserver.TableIterator#getRow}.

* @return {number} The table row.
*/
    readonly tableRow: number;
    /**
*  Resets the iterator and then copies values from an array into the underlying {@link com.bayesserver.Table} using the variable ordering of the {@link com.bayesserver.TableIterator}, not the {@link com.bayesserver.Table#getSortedVariables}.
*
* At the end of the operation the iterator will be reset to the start.
*
* @param {number[]} values An array of values to copy.

* @exception ReferenceError Raised if [values] is null.

* @exception Error Raised if [values] is too short.
*/
    copyFrom(values: number[]): void;
    /**
*  Resets the iterator to the start.
*/
    reset(): void;
    /**
*  Gets the states of all nodes, based on the order of nodes in the {@link com.bayesserver.TableIterator} not the underlying {@link com.bayesserver.Table}.
*
* @param {number[]} states A array, whose values will be replaced.  The [states] array must have length equal to or greater than the node count in the underlying {@link com.bayesserver.Table}.

* @exception ReferenceError Raised if [states] is null.

* @exception Error Raised if [states] is too short.
*/
    getStates(states: number[]): void;
    /**
*  Gets the state for an individual node indexed by the order of nodes in the {@link com.bayesserver.TableIterator}.
*
* @param {number} i The node position, based on the order of nodes in the {@link com.bayesserver.TableIterator}.

* @return {number} The state.
*/
    getState(i: number): number;
}
/**
*  The maximum value and the index of the maximum value in a Table.
*/
export declare class TableMaxValue {
    private _Dbf_x_;
    private _Dbg_x_;
    constructor(p_autogen0: number, p_autogen1: number);
    /**
*  Gets the position (zero based index) of the maximum value in the Table.
*/
    readonly index: number;
    /**
*  Gets the maximum value found.
*/
    readonly value: number;
}
/**
*  Used to report non zero table values.
*/
export interface ITableNonZeroValues {
    value(index: number, value: number): void;
}
/**
*  The node type for networks that include temporal/sequential support.  I.e. Dynamic Bayesian Networks (DBN).
*/
export declare class TemporalType {
    /**
*  A standard node that is not repeated at each time step.
*
*  If a {@link com.bayesserver.TemporalType#Contemporal} node has an outgoing link to a {@link com.bayesserver.TemporalType#Temporal} node, it is equivalent to the single Contemporal node having an outgoing link to the Temporal node at each time slice.
*/
    static readonly Contemporal: TemporalType;
    /**
        *  A temporal node, which can be queried or have evidence set at each time step.
        */
    static readonly Temporal: TemporalType;
    /**
*  A node which cannot link to temporal nodes at time t > 0.
*
* If an {@link com.bayesserver.TemporalType#Initial} node links to a {@link com.bayesserver.TemporalType#Temporal} node then the link is only valid for t=0.
*/
    static readonly Initial: TemporalType;
    /**
        *  A node which cannot link to temporal nodes except for the last time slice.
        */
    static readonly Terminal: TemporalType;
}
/**
*  Contains methods to sort nodes in a Bayesian network in topological order.
*/
export declare class TopologicalSort {
    /**
*  Returns the nodes in a Bayesian network sorted in topological order.
*
* @param {Network} network The Bayesian network.

* @return {Node[]} The nodes sorted in topological order.
*/
    static sort(network: Network): Node[];
}
/**
*  Unrolls a Dynamic Bayesian network into the equivalent Bayesian network.
*/
export declare class Unroller {
    /**
*  Unrolls the specified Dynamic Bayesian network into the equivalent Bayesian network.
*
* @param {Network} network The Dynamic Bayesian network.
*
* @param {number} sliceCount The slice count (number of time slices).
*
* @param {UnrollOptions} options Options that govern the unroll operation.

* @return {UnrollOutput} The unrolled network along with additional information.
*/
    static unroll(network: Network, sliceCount: number, options: UnrollOptions): UnrollOutput;
    private static _vvu_x_(p_autogen3, p_autogen4, p_autogen5, p_autogen6, p_autogen7);
    private static _vvv_x_(p_autogen8, p_autogen9, p_autogen10, p_autogen11);
}
/**
*  Options governing the unrolling of a Dynamic Bayesian network.

* @see com.bayesserver.Unroller
*/
export declare class UnrollOptions {
    private _Dce_x_;
    private _Dcf_x_;
    /**
*  Gets the gap between time slices.

* @return {number} The gap between time slices.
*/
    /**
*  Sets the gap between time slices.
*
* @param {number} value The gap between time slices.
*/
    sliceGap: number;
    /**
*  Gets a value that can be used to override the width of nodes, used when laying out nodes.

* @return {?number} Value to override node widths.
*/
    /**
*  Sets a value that can be used to override the width of nodes, used when laying out nodes.
*
* @param {?number} value Value to override node widths.
*/
    nodeWidthOverride: number | null;
}
/**
*  Contains information returned by {@link com.bayesserver.Unroller#unroll}.
*/
export declare class UnrollOutput {
    private _Dcg_x_;
    private _Dch_x_;
    private _Dda_x_;
    private _Ddb_x_;
    private _Ddc_x_;
    private _Ddd_x_;
    constructor(p_autogen0: Network, p_autogen1: Network, p_autogen2: Map<Node, number>, p_autogen3: Map<Node, Node>, p_autogen4: Map<Node, number>, p_autogen5: number);
    /**
*  Gets the Dynamic Bayesian network before it was unrolled.

* @return {Network} The Dynamic Bayesian network.
*/
    readonly dbn: Network;
    /**
*  Gets the unrolled Dynamic Bayesian network.
*/
    readonly unrolled: Network;
    /**
*  Gets the slice count of the unrolled network.

* @return {number} The slice count.
*/
    readonly sliceCount: number;
    /**
*  Maps from a variable in the unrolled network to the corresponding variable in the original Dynamic Bayesian network.
*
* @param {Variable} unrolledVariable The unrolled variable.

* @return {VariableTime} The variable in the original Dynamic Bayesian network, and the time that it corresponds to.
*/
    getDbnVariable(unrolledVariable: Variable): VariableTime;
    /**
*  Maps from a node in the unrolled network to the corresponding node in the original Dynamic Bayesian network.
*
* @param {Node} unrolledNode The unrolled node.

* @return {NodeTime} The node in the original Dynamic Bayesian network, and the time that the unrolled node represents.
*/
    getDbnNode(unrolledNode: Node): NodeTime;
    /**
*  Maps between a node in the original Dynamic Bayesian network, and the corresponding node in the unrolled network.
*
* @param {Node} dbnNode The node in the original Dynamic Bayesian network.
*
* @param {?number} time The time at which to retrieve the corresponding unrolled node.

* @return {Node} The node in the unrolled network.
*/
    getUnrolledNode(dbnNode: Node, time: number | null): Node;
    /**
*  Maps between a variable in the original Dynamic Bayesian network, and the corresponding variable in the unrolled network.
*
* @param {Variable} dbnVariable The variable in the original Dynamic Bayesian network.
*
* @param {?number} time The time at which to retrieve the corresponding unrolled variable.

* @return {Variable} The variable in the unrolled network.
*/
    getUnrolledVariable(dbnVariable: Variable, time: number | null): Variable;
}
/**
*  Represents options that govern the validation of a network.  See {@link com.bayesserver.Network#validate}.
*/
export declare class ValidationOptions {
    private _Dde_x_;
    /**
*  Determines whether validation should succeed even if the required distribution(s) have not been assigned to a node.  Default value is false.
*
* Temporal nodes (Dynamic Bayesian networks) may require multiple distributions to be specified.
*/
    /**
*  Determines whether validation should succeed even if the required distribution(s) have not been assigned to a node.  Default value is false.
*
* Temporal nodes (Dynamic Bayesian networks) may require multiple distributions to be specified.
*/
    allowNullDistributions: boolean;
}
/**
*  Represents a discrete or continuous random variable.
*
*  Note that variable names must be unique per network, and are case sensitive.
* <p> A {@link com.bayesserver.Node Node} in a Bayesian network can contain one or more variables.</p>

* <p>Although a discrete variable can contain a different number of {@link com.bayesserver.State states}, a continuous variable always contains a single state.</p>

*/
export declare class Variable {
    private static _Ddf_x_;
    private _Ddg_x_;
    private _Ddh_x_;
    private _Dea_x_;
    private _Deb_x_;
    private _Dec_x_;
    private _Ded_x_;
    private _Dee_x_;
    private _Def_x_;
    private _Deg_x_;
    private _Deh_x_;
    private _Dfa_x_;
    private _Dfb_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.Variable} class, with {@link com.bayesserver.VariableValueType} discrete and zero states.
*/
    constructor();
    /**
*  Initializes a new instance of the {@link com.bayesserver.Variable} class, with {@link com.bayesserver.VariableValueType} discrete, zero states, and the specified name.
*
* @param {string} name The name of the variable.  Can be null.
*/
    constructor(name: string);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Variable} class with the specified name, kind and value type.  If discrete, no states are added.
*
* @param {string} name The name of the variable.  Can be null.
*
* @param {VariableValueType} valueType The value type, e.g. continuous or discrete.
*
* @param {VariableKind} kind The kind of Variable, e.g. Probability, Decision or Utility.
*/
    constructor(name: string, valueType: VariableValueType, kind: VariableKind);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Variable} class with the specified name and value type.  If discrete, no states are added.
*
* @param {string} name The name of the variable.  Can be null.
*
* @param {VariableValueType} valueType The value type, e.g. continuous or discrete.
*/
    constructor(name: string, valueType: VariableValueType);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Variable} class, with {@link com.bayesserver.VariableValueType} discrete and the specified [name] and adds the number of states specified in [states].
*
* @param {string} name The name to give the Variable, which can be null or empty.
*
* @param {number} states The number of states to add to the Variable.  States will be given default names.

* @exception RangeError Raised when the [states] parameter is less than zero.
*/
    constructor(name: string, states: number);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Variable} class, with {@link com.bayesserver.VariableValueType} discrete and the specified name and adds the states specified in [states].
*
* @param {string} name The name of the node and variable.
*
* @param {string[]} states The states to add to the associated {@link com.bayesserver.Variable}, specified by their names.

* @exception ReferenceError Raised when [states] is null.

* @exception Error Raised when the names in [states] are not unique, or are null or empty.
*/
    constructor(name: string, states: string[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.Variable} class, with {@link com.bayesserver.VariableValueType} discrete and the specified name and adds the states specified in [states].
*
* @param {string} name The name of the node and variable.
*
* @param {State[]} states The states to add to the associated {@link com.bayesserver.Variable}.

* @exception ReferenceError Raised when [states] is null.

* @exception Error Raised when the names in [states] are not unique, or are null or empty.
*/
    constructor(name: string, states: State[]);
    private _cons_autogen0();
    private _cons_autogen1(name);
    private _cons_autogen2(name, valueType, kind);
    private _cons_autogen3(name, valueType);
    private _cons_autogen4(name, states);
    private _cons_autogen5(name, states);
    private _cons_autogen6(name, states);
    _rqqq_x_(): void;
    /**
*  Finds a state based on a state value.  E.g. finds the state who's interval contains the supplied value, or who's integer state value matches the supplied integer.
*
* @param {object} value The value to test against state values.  Type will depend on StateValueType.  e.g. pass a double if the state value type is a double interval.

* @return {State} The matching state or null.
*/
    findStateByValue(value: any): State;
    /**
* @inheritDoc
*/
    compareTo(other: Variable): number;
    /**
*  Gets the type of value that states belonging to this variable can represent.  For example an interval.
*/
    /**
*  Sets the type of value that states belonging to this variable can represent.  For example an interval.
*/
    stateValueType: StateValueType;
    private _rqqt_x_(p_autogen6);
    _rqqu_x_(): void;
    /**
*  Copies this instance.

* @return {Variable} A new {@link com.bayesserver.Variable} instance.
*/
    copy(): Variable;
    /**
*  Gets custom properties associated with this instance.
*
*  Custom properties allow storage of custom information, which will be saved with the network.
*/
    readonly customProperties: CustomPropertyCollection;
    private _rqqv_x_(p_autogen7, p_autogen8);
    private _rqrq_x_(p_autogen9, p_autogen10, p_autogen11);
    /**
*  An optional description for the variable.
*/
    /**
*  An optional description for the variable.
*/
    description: string;
    /**
*  Gets the variable's value type, e.g. continuous or discrete.

* @return {VariableValueType} The variable's value type.
*/
    readonly valueType: VariableValueType;
    /**
*  Gets the kind of variable, such as Probability, Decision or Utility.
*/
    readonly kind: VariableKind;
    /**
*  Returns the collection of states belonging to the variable.
*
* Continuous variables always have a single state.

* @see com.bayesserver.State
*/
    readonly states: StateCollection;
    /**
*  Returns the name of the variable, or an empty string if the name is null.

* @return {string}  A {@link String} containing the name of the variable which is empty if the name is null.
*/
    toString(): string;
    /**
*  Gets the {@link com.bayesserver.Node} this instance belongs to, if any.

* @return {Node} The node the instance belongs to, if any.
*/
    readonly node: Node;
    _setNode(value: Node): void;
    /**
*  Gets the name of the variable.
*
* When a variable is added to a network, its name must be unique.  Comparisons are case sensitive.
*/
    /**
*  Sets the name of the variable.
*
* When a variable is added to a network, its name must be unique.  Comparisons are case sensitive.
*/
    name: string;
    /**
*  The Index of this instance in the collection of variables belonging to a network, or -1 if the variable does not belong to a node and hence a network.
*/
    readonly index: number;
    _setIndex(value: number): void;
    _rqrr_x_(p_autogen24: string): void;
    _rqrs_x_(p_autogen25: State): void;
    _rqrt_x_(p_autogen26: string): void;
    _rqru_x_(p_autogen27: State, p_autogen28: string, p_autogen29: string): void;
    _get_O_x_(): VariableId;
    _set_O_x_(value: VariableId): void;
    private static _rqqr_x_<T>(p_autogen1, p_autogen2);
    private static _rqqs_x_(p_autogen4, p_autogen5);
}
/**
*  Represents a variable and associated information such as time, and whether it is marked as head or tail.
*
*  A {@link com.bayesserver.VariableContext} is used to store contextual information about a variable in a distribution, such as whether it is marked as head or tail, and time if the variable belongs to a temporal node. The same variable can appear more than once in a distribution if it appears at different times.
*/
export declare class VariableContext {
    private _Dff_x_;
    private _Dfg_x_;
    private _Dfh_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.VariableContext} class, copying an existing instance.
*
* @param {VariableContext} variableContext The variable context to copy.
*/
    constructor(variableContext: VariableContext);
    /**
*  Initializes a new instance of the {@link com.bayesserver.VariableContext} class.  Time defaults to null and HeadTail to Head.
*
* @param {Variable} variable The variable.
*/
    constructor(variable: Variable);
    /**
*  Initializes a new instance of the {@link com.bayesserver.VariableContext} class.  Time defaults to null.
*
* @param {Variable} variable The variable.
*
* @param {HeadTail} headTail Indicates whether the variable is marked as head or tail.
*/
    constructor(variable: Variable, headTail: HeadTail);
    /**
*  Initializes a new instance of the {@link com.bayesserver.VariableContext} class.  HeadTail defaults to Head.
*
* @param {Variable} variable The variable.
*
* @param {?number} time The time associated with the variable.  Can be null.
*/
    constructor(variable: Variable, time: number | null);
    /**
*  Initializes a new instance of the {@link com.bayesserver.VariableContext} class.
*
* @param {Variable} variable The variable.
*
* @param {?number} time The time associated with the variable.  Can be null.
*
* @param {HeadTail} headTail Indicates whether the variable is marked as head or tail.
*/
    constructor(variable: Variable, time: number | null, headTail: HeadTail);
    private _cons_autogen0(variableContext);
    private _cons_autogen1(variable);
    private _cons_autogen2(variable, headTail);
    private _cons_autogen3(variable, time);
    private _cons_autogen4(variable, time, headTail);
    private _rqsq_x_(p_autogen9);
    private _rqsr_x_(p_autogen10, p_autogen11, p_autogen12);
    /**
*  Specifies whether the variable is marked as Head or Tail.

* @return {HeadTail} Specified either Head or Tail.

* @see com.bayesserver.HeadTail
*/
    readonly headTail: HeadTail;
    _setHeadTail(value: HeadTail): void;
    /**
*  Gets the variable.

* @return {Variable} The variable.
*/
    readonly variable: Variable;
    /**
*  Gets the time associated with the variable if it belongs to a temporal node.

* @return {?number} The time associated with the variable.  Null if the variable does not belong to a temporal node.
*/
    readonly time: number | null;
    _setTime(value: number | null): void;
    /**
*  Determines whether this instance is marked as Head.

* @return {boolean} <code>true</code> if this instance is marked as Head; otherwise, <code>false</code>.

* @see com.bayesserver.HeadTail
*/
    isHead(): boolean;
    /**
*  Determines whether this instance is marked as Tail.

* @return {boolean} <code>true</code> if this instance is marked as Tail; otherwise, <code>false</code>.

* @see com.bayesserver.HeadTail
*/
    isTail(): boolean;
}
/**
*  Represents a read-only collection of variables.
*
* Each variable in the collection may have an associated time if the Bayesian network is a Dynamic Bayesian network (DBN).  A variable can only appear more than once in the collection if it has different times associated. All variables are marked as either head or tail.  Head variables are those on the left, and tail variables are those on the right in the expression P(A|B).
*/
export declare class VariableContextCollection implements IList<VariableContext> {
    private _Dga_x_;
    private static _Dgb_x_;
    private _Dgc_x_;
    private static _Dgd_x_;
    private _items;
    private static _Dge_x_;
    private _Dgf_x_;
    constructor(p_autogen0: VariableContextCollection);
    constructor(p_autogen2: VariableContextCollection, p_autogen3: number | null);
    constructor(p_autogen4: VariableContext[], p_autogen5: boolean);
    private _cons_autogen0(p_autogen0);
    private _cons_autogen1(p_autogen2, p_autogen3);
    private _cons_autogen2(p_autogen4, p_autogen5);
    /**
* @inheritDoc
*/
    _2ad2e5f4b2884a52bf8bfc07ce8953d3(): void;
    /**
*  Returns a {@link String} that represents the current {@link Object}.

* @return {string}  A {@link String} that represents the current {@link Object}.
*/
    toString(): string;
    [Symbol.iterator](): Iterator<VariableContext>;
    _rqss_x_(p_autogen1: number): void;
    private _rqst_x_(p_autogen6, p_autogen7, p_autogen8);
    /**
*  Gets the number of elements contained in the collection.
*/
    readonly size: number;
    /**
*  Determines the index of a specific {@link com.bayesserver.Variable} in the collection.
*
* @param {Variable} item The variable to find.  The value can be null.

* @return {number} The index of the variable or -1 if not found.
*/
    indexOf(item: Variable): number;
    /**
*  Determines the index of a specific variable-time combination in the collection.
*
* @param {VariableContext} variableContext The variable context to match.
*
* @param {boolean} ignoreHeadTail When true, the Head and Tail specifications need not match.

* @return {number} The index of the variable or -1 if not found.
*/
    indexOf(variableContext: VariableContext, ignoreHeadTail: boolean): number;
    /**
*  Determines the index of a specific {@link com.bayesserver.VariableContext} in the collection at the specified [time].
*
* @param {VariableContext} variableContext The variable context to find.

* @return {number} The index of the variable context or -1 if not found.
*/
    indexOf(variableContext: VariableContext): number;
    /**
*  Determines the index of a specific {@link com.bayesserver.Variable} in the collection at the specified [time].
*
* @param {Variable} variable The variable to find.
*
* @param {?number} time The variable time.  Can be null for non temporal variables.

* @return {number} The index of the variable or -1 if not found.
*/
    indexOf(variable: Variable, time: number | null): number;
    private _IndexOf_autogen0(item);
    private _IndexOf_autogen1(variableContext, ignoreHeadTail);
    private _IndexOf_autogen2(variableContext);
    private _IndexOf_autogen3(variable, time);
    /**
*  Determines whether a {@link com.bayesserver.Variable} is in the collection.
*
* @param {Variable} variable The {@link com.bayesserver.Variable} to locate in the collection. The value can be null.

* @return {boolean} true if [variable] is found in the collection; otherwise, false.
*/
    includes(variable: Variable): boolean;
    /**
*  Determines whether a variable-time (and optionally Head/Tail) combination is contained in the collection.
*
* @param {VariableContext} variableContext The variableContext to match.
*
* @param {boolean} ignoreHeadTail When true, the Head and Tail specifications need not match.

* @return {boolean} True if a match is found; false otherwise.
*/
    includes(variableContext: VariableContext, ignoreHeadTail: boolean): boolean;
    /**
*  Determines whether a {@link com.bayesserver.Variable} is in the collection at the specified [time].
*
* @param {Variable} variable The {@link com.bayesserver.Variable} to locate in the collection. The value can be null.
*
* @param {?number} time The time associated with the variable, if any.  Can be null.

* @return {boolean} true if [variable] is found in the collection; otherwise, false.
*/
    includes(variable: Variable, time: number | null): boolean;
    includes(value: VariableContext): boolean;
    private _Includes_autogen0(variable);
    private _Includes_autogen1(variableContext, ignoreHeadTail);
    private _Includes_autogen2(variable, time);
    private _Includes_autogen3(value);
    /**
*  Determines whether all [items] are matched in the collection.
*
* @param {IList<Variable>} items The items to locate in the collection. Cannot be null.

* @return {boolean} true if all items were matched in the collection; otherwise, false.

* @exception ReferenceError Raised when [items] is null.
*/
    includesAll(items: IList<Variable>): boolean;
    /**
*  Determines whether all [items] are matched in the collection.
*
* @param {IList<Variable>} items The items to locate in the collection. Cannot be null.
*
* @param {IList<int?>} times The times associated with [items].  Can be null.

* @return {boolean} true if all items were matched in the collection; otherwise, false.

* @exception ReferenceError Raised when [items] is null.
*/
    includesAll(items: IList<Variable>, times: IList<number | null>): boolean;
    /**
*  Determines whether all [items] are matched in the collection at the specified times.
*
* @param {IList<VariableContext>} items The items to locate in the collection. Cannot be null.
*
* @param {boolean} ignoreHeadTail When true, head and tail specifications need not match.

* @return {boolean} true if all items were matched in the collection; otherwise, false.

* @exception ReferenceError Raised when [items] is null.
*/
    includesAll(items: IList<VariableContext>, ignoreHeadTail: boolean): boolean;
    /**
*  Determines whether all [items] are matched in the collection.
*
* @param {VariableContextCollection} items The items to locate in the collection. Cannot be null.
*
* @param {boolean} ignoreHeadTail When true, the Head and Tail specifications need not match.

* @return {boolean} true if all items were matched in the collection; otherwise, false.

* @exception ReferenceError Raised when [items] is null.
*/
    includesAll(items: VariableContextCollection, ignoreHeadTail: boolean): boolean;
    private _IncludesAll_autogen0(items);
    private _IncludesAll_autogen1(items, times);
    private _IncludesAll_autogen2(items, ignoreHeadTail);
    private _IncludesAll_autogen3(items, ignoreHeadTail);
    /**
*  Determines whether any [items] are matched in the collection.
*
* @param {VariableContextCollection} items The items to locate in the collection. Cannot be null.
*
* @param {boolean} ignoreHeadTail When true, the Head and Tail specifications need not match.

* @return {boolean} true if any items were matched in the collection; otherwise, false.

* @exception ReferenceError Raised when [items] is null.
*/
    includesAny(items: VariableContextCollection, ignoreHeadTail: boolean): boolean;
    /**
*  Determines whether any [items] are matched in the collection.
*
* @param {IList<Variable>} items The items to locate in the collection. Cannot be null.
*
* @param {IList<int?>} times The time for each variable.  Each time can be null for non temporal variables.  [times] can be null.

* @return {boolean} true if any items were matched in the collection; otherwise, false.

* @exception ReferenceError Raised when [items] is null.
*/
    includesAny(items: IList<Variable>, times: IList<number | null>): boolean;
    private _IncludesAny_autogen0(items, ignoreHeadTail);
    private _IncludesAny_autogen1(items, times);
    /**
*  Gets the {@link com.bayesserver.Variable} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Variable} to find.

* @return {VariableContext} A {@link com.bayesserver.Variable}.
*/
    get(index: number): VariableContext;
    /**
*  Gets the {@link com.bayesserver.Variable} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Variable} to find.

* @return {void} A {@link com.bayesserver.Variable}.
*/
    /**
*  Gets the {@link com.bayesserver.Variable} object at the specified index.
*
* @param {number} index The zero-based index of the {@link com.bayesserver.Variable} to find.
*/
    set(index: number, value: VariableContext): void;
    push(...items: VariableContext[]): number;
    clear(): void;
    insert(index: number, item: VariableContext): void;
    removeAt(index: number): VariableContext;
    remove(item: VariableContext): boolean;
}
/**
*  The kind of variable, such as Probability, Decision or Utility.
*/
export declare class VariableKind {
    /**
*  A standard probability variable.
*/
    static readonly Probability: VariableKind;
    /**
*  A decision variable, which can be used for decision making based on utilities.
*/
    static readonly Decision: VariableKind;
    /**
*  A utility variable, which can be used to encode utilities such as costs and profits.
*/
    static readonly Utility: VariableKind;
}
/**
*  Maps between a custom variable order and the default sorted variable order.

* @see com.bayesserver.IDistribution#getSortedVariables
*/
export declare class VariableMap {
    private _Dgg_x_;
    /**
*  Initializes a new instance of the {@link com.bayesserver.VariableMap} class.
*
* @param {VariableContextCollection} sortedVariables The sorted variables.
*
* @param {IList<Variable>} order The  custom order, without times.

* @exception ReferenceError Raised if [sortedVariables] or [order] is null.

* @exception Error Raised if the elements in [order] are not found in [sortedVariables].
*/
    constructor(sortedVariables: VariableContextCollection, order: IList<Variable>);
    constructor(sortedVariables: VariableContextCollection, order: IList<VariableContext>);
    constructor(sortedVariables: VariableContextCollection, order: VariableContext[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.VariableMap} class.
*
* @param {VariableContextCollection} sortedVariables The sorted variables.
*
* @param {IList<Variable>} order The custom order.
*
* @param {IList<int?>} times The times associated with the variables in [order].  Each entry can be null.

* @exception ReferenceError Raised if [sortedVariables] or [order] is null.

* @exception Error Raised if the elements in [order] are not found in [sortedVariables].
*/
    constructor(sortedVariables: VariableContextCollection, order: IList<Variable>, times: IList<number | null>);
    /**
*  Initializes a new instance of the {@link com.bayesserver.VariableMap} class.
*
* @param {VariableContextCollection} sortedVariables The sorted variables.
*
* @param {Variable[]} order The custom order.
*
* @param {?number[]} times The times associated with the variables in [order].  Each entry can be null.

* @exception ReferenceError Raised if [sortedVariables] or [order] is null.

* @exception Error Raised if the elements in [order] are not found in [sortedVariables].
*/
    constructor(sortedVariables: VariableContextCollection, order: Variable[], times: (number | null)[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.VariableMap} class.
*
* @param {VariableContextCollection} sortedVariables The sorted variables.
*
* @param {Variable[]} order The custom order.

* @exception ReferenceError Raised if [sortedVariables] or [order] is null.

* @exception Error Raised if the elements in [order] are not found in [sortedVariables].
*/
    constructor(sortedVariables: VariableContextCollection, order: Variable[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.VariableMap} class.
*
* @param {VariableContextCollection} sortedVariables The sorted variables.
*
* @param {Node[]} order The custom order, specified by nodes without times.  If each node does not contain a single variable, use a different constructor.

* @exception ReferenceError Raised if [sortedVariables] or [order] is null.

* @exception Error Raised if the elements in [order] are not found in [sortedVariables].
*/
    constructor(sortedVariables: VariableContextCollection, order: Node[]);
    /**
*  Initializes a new instance of the {@link com.bayesserver.VariableMap} class.
*
* @param {VariableContextCollection} sortedVariables The sorted variables.
*
* @param {IList<Node>} order The custom order, specified by nodes without times.  If each node does not contain a single variable, use a different constructor.

* @exception ReferenceError Raised if [sortedVariables] or [order] is null.

* @exception Error Raised if the elements in [order] are not found in [sortedVariables].
*/
    constructor(sortedVariables: VariableContextCollection, order: IList<Node>);
    private _cons_autogen0(sortedVariables, order);
    private _cons_autogen1(sortedVariables, order);
    private _cons_autogen2(sortedVariables, order);
    private _cons_autogen3(sortedVariables, order, times);
    private _cons_autogen4(sortedVariables, order, times);
    private _cons_autogen5(sortedVariables, order);
    private _cons_autogen6(sortedVariables, order);
    private _cons_autogen7(sortedVariables, order);
    private _initialize(sortedVariables, order, times);
    private _initialize(sortedVariables, order);
    private __initialize_autogen0(sortedVariables, order, times);
    private __initialize_autogen1(sortedVariables, order);
    /**
*  Maps between the custom order and the sorted collection.
*
* @param {number} orderIndex Index of the variable in the custom order.

* @return {number} The index of the variable in the sorted collection.
*/
    get(orderIndex: number): number;
}
/**
*  Identifies a variable and related time.
*/
export declare class VariableTime {
    private _Dgh_x_;
    private _Dha_x_;
    constructor();
    constructor(p_autogen0: Variable, p_autogen1: number | null);
    private _cons_autogen0();
    private _cons_autogen1(p_autogen0, p_autogen1);
    /**
*  Gets the variable.
*/
    readonly variable: Variable;
    _setVariable(value: Variable): void;
    /**
*  Gets the time of the variable, or null if a time is not appropriate for the temporal type of the variable.
*/
    readonly time: number | null;
    _setTime(value: number | null): void;
}
/**
*  The type of data represented by a {@link com.bayesserver.Variable}.
*/
export declare class VariableValueType {
    /**
*  Discrete/Categorical/Nominal data.  E.g. Gender = {Male, Female}
*/
    static readonly Discrete: VariableValueType;
    /**
*  Continuous data. E.g. Stock price.
*/
    static readonly Continuous: VariableValueType;
}
export interface IRandom {
    nextDouble(): number;
    next(minValue: number, maxValue: number): number;
}
/**
*  Default implementation of IRandom.
*/
export declare class Random implements IRandom {
    private static readonly _Dhd_x_;
    private static readonly _Dhe_x_;
    private static readonly _Dhf_x_;
    private static readonly _Dhg_x_;
    private _Dhh_x_;
    private _Eaa_x_;
    private _Eab_x_;
    constructor();
    constructor(seed: number);
    private _cons_autogen0();
    private _cons_autogen1(seed);
    next(minValue: number, maxValue: number): number;
    private sample();
    private _rqtr_x_(p_autogen1);
    /**
* @inheritDoc
*/
    nextDouble(): number;
    private _rqts_x_();
}
export interface IList<T> extends Iterable<T> {
    _2ad2e5f4b2884a52bf8bfc07ce8953d3(): void;
    readonly size: number;
    get(index: number): T;
    set(index: number, value: T): void;
    push(...items: T[]): number;
    insert(index: number, item: T): void;
    clear(): void;
    remove(item: T): void;
    removeAt(index: number): T;
    indexOf(searchElement: T): number;
    includes(element: T): boolean;
}
